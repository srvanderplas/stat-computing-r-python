{
  "hash": "627545e248bf7a6e1ab5facde7732988",
  "result": {
    "engine": "knitr",
    "markdown": "# Introduction to Programming {#sec-intro-prog}\n\n## Objectives {.nonumber}\n\n- Define programming and provide examples of programming\n- Identify reserved words in R and python\n- Know how to get help when using R and python\n\n## What is Programming?\n\n> Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. - Rick Cook\n\nProgramming is the art of solving a problem by developing a sequence of steps that make up a solution, and then very carefully communicating those steps to the computer.\nTo program, you need to know how to\n\n- break a problem down into smaller, easily solvable problems\n- solve the small problems\n- communicate the solution to a computer using a programming language\n\nIn this book, we'll be using both R and Python, and we'll be using these languages to solve problems that are related to working with data.\nAt first, we'll start with smaller, simpler problems that don't involve data, but by the end, you will hopefully be able to solve some statistical problems using one or both languages.\n\nIt will be hard at first - you have to learn the vocabulary in both languages in order to be able to put commands into logical \"sentences\".\nThe problem solving skills are the same for all programming languages, though, and while those are harder to learn, they'll last you a lifetime.\n\nJust as you wouldn't expect to learn French or Mandarin fluently after taking a single class, you cannot expect to be fluent in R or python once you've worked through this book.\nFluency takes years of work and practice, and lots of mistakes along the way.\nYou *cannot* learn a language (programming or otherwise) if you're worried about making mistakes.\n\n::: column-margin\nTake a minute and put those concerns away, take a deep breath, and remember the Magic School Bus Motto:\n\n![For those who don't know, the Magic School Bus is a PBS series that aired in the 1990s and was brought back by Netflix in 2017. It taught kids about different principles of science and the natural world.](../images/gen-prog/ms-frizzle.png){fig-alt=\"A picture of Ms. Frizzle, a teacher with red curly hair and a lizard around her neck, saying 'Take chances, make mistakes, get messy'\"}\n:::\n\n## Strategies for Programming\n\nAs you start to program, you will need to develop some skill at reading and interpreting error messages, breaking problems down into smaller parts, and thinking through what code instructs the computer to do. \nIt's useful to at least mention some strategies here, though @sec-debugging goes into much more detail. \n\n1. Google the error message (or put the code and the error into AI and ask it to explain why there is an error). \n\n2. Make a list of steps or a flowchart illustrating what the code does, breaking the code down into smaller pieces each time.\n\nKeep an eye out for how these strategies are used in @sec-basic-var-types and @sec-use-functions. \n\n\n## Programming Vocabulary: Hello World\n\nI particularly like the way that Python for Everybody [@py4e] explains vocabulary (my changes in parentheses):\n\n> Unlike human languages, the (R and) Python vocabulary is actually pretty small. We call this \"vocabulary\" the \"reserved words\". These are words that have very special meaning to (R and) Python. When (R) Python sees these words in a (R) Python program, they have one and only one meaning to (R) Python. Later as you write programs you will make up your own words that have meaning to you called variables. You will have great latitude in choosing your names for your variables, but you cannot use any of (R or) Python's reserved words as a name for a variable.\n\n> When we train a dog, we use special words like \"sit\", \"stay\", and \"fetch\". When you talk to a dog and don't use any of the reserved words, they just look at you with a quizzical look on their face until you say a reserved word. For example, if you say, \"I wish more people would walk to improve their overall health\", what most dogs likely hear is, \"blah blah blah walk blah blah blah blah.\" That is because \"walk\" is a reserved word in dog language. Many might suggest that the language between humans and cats has no reserved words.\n\n::: panel-tabset\n\n### Python\n\n> The reserved words in the language where humans talk to Python include the following:\n\n    and       del       global      not       with\n    as        elif      if          or        yield\n    assert    else      import      pass\n    break     except    in          raise\n    class     finally   is          return\n    continue  for       lambda      try\n    def       from      nonlocal    while\n\n### R\n\n> The reserved words in the language where humans talk to R include the following:\n\n    if          else     repeat      while\n    for         in       next        break\n    TRUE        FALSE    NULL        Inf\n    NA_integer_ NA_real_ NA_complex_ NA_character_\n    NaN         NA       function    ...\n\n:::\n\n\n> That is it, and unlike a dog, (R) Python is already completely trained. When you say 'try', (R) Python will try every time you say it without fail.\n\n> We will learn these reserved words and how they are used in good time, but for now we will focus on the (R) Python equivalent of \"speak\" (in human-to-dog language). The nice thing about telling (R and) Python to speak is that we can even tell it what to say by giving it a message in quotes:\n\n::: panel-tabset\n### Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint('Hello world!')\n## Hello world!\n```\n:::\n\n\n\n\n### R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint('Hello world!')\n## [1] \"Hello world!\"\n```\n:::\n\n\n\n\n:::\n\nThe \"Hello World\" program looks exactly the same in R as it does in python!\n\n> And we have even written our first syntactically correct (R and) Python sentence. Our sentence starts with the function print followed by a string of text of our choosing enclosed in single quotes. The strings in the print statements are enclosed in quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string.\n\n\nIn many situations, R and python will be similar because both languages are based on C. \nR has a more complicated history [@ihakaFutureHistory1998], because it is also similar to Lisp, but both languages are still very similar to C and often run C or C++ code in the background.\n\n::: example\n### Reserved Word Errors {-}\n\nWhat happens when we try to assign a new value to a reserved word? We'll learn more about **assignment** in the next chapter, but for now, know it is equivalent to setting the value of a variable. \n`x = 3` or `x <- 3` defines the variable $x$ as having the value 3. \n\n::: panel-tabset\n\n#### R {-}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor <- 3 # <1>\n## Error in parse(text = input): <text>:1:5: unexpected assignment\n## 1: for <-\n##         ^\n```\n:::\n\n\n\n1. We just tried to assign the value 3 to the word `for`. `for` is a reserved word and cannot have a different value assigned to it, so we get an unexpected assignment error.\n\nWhen we assign the value of a non-reserved word, things work just fine: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3 # <1>\n```\n:::\n\n\n\n1. x is not a reserved word, so we can safely assign x the value 3 without getting any errors. \n\n![RStudio alerts us to the syntax error in the left column of the editor window and even helps identify the error via mouseover text.](../images/tools/RStudio-error-indicator-reserved.png){#fig-assign-reserved-word fig-alt=\"A code line reading `for <- 3` has a red X next to the line number. Mouseover text says 'unexpected token '<-', expected 'LPAREN'.\" width=\"100%\"}\n\n#### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor = 3 # <1>\n## invalid syntax (<string>, line 1)\n```\n:::\n\n\n\n1. We just tried to assign the value 3 to the word `for`. `for` is a reserved word and cannot have a different value assigned to it, so we get an invalid syntax error located at the `=`. \n\nWhen we assign the value of a non-reserved word, things work just fine: \n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 3 # <1>\n```\n:::\n\n\n\n1. x is not a reserved word, so we can safely assign x the value 3 without getting any errors. \n\n:::\n\n:::\n\n\n## Getting help\n\nIn both R and python, you can access help with a `?` via the terminal/console.\n\n::: demo\n### Demo: Getting Help {-}\n\n::: panel-tabset\n#### R {-}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?list # Get help with the list function\n```\n:::\n\n\n\n\n#### Python {-}\n\nSometimes, it is easier to start a python terminal outside of RStudio (or in the RStudio terminal window), as the `reticulate` R package that allows us to run python code doesn't always react the same as the normal python terminal.  \nHelp is one particular case where this seems to be true\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nhelp(list)\n## Help on class list in module builtins:\n## \n## class list(object)\n##  |  list(iterable=(), /)\n##  |  \n##  |  Built-in mutable sequence.\n##  |  \n##  |  If no argument is given, the constructor creates a new empty list.\n##  |  The argument must be an iterable if specified.\n##  |  \n##  |  Methods defined here:\n##  |  \n##  |  __add__(self, value, /)\n##  |      Return self+value.\n##  |  \n##  |  __contains__(self, key, /)\n##  |      Return key in self.\n##  |  \n##  |  __delitem__(self, key, /)\n##  |      Delete self[key].\n##  |  \n##  |  __eq__(self, value, /)\n##  |      Return self==value.\n##  |  \n##  |  __ge__(self, value, /)\n##  |      Return self>=value.\n##  |  \n##  |  __getattribute__(self, name, /)\n##  |      Return getattr(self, name).\n##  |  \n##  |  __getitem__(...)\n##  |      x.__getitem__(y) <==> x[y]\n##  |  \n##  |  __gt__(self, value, /)\n##  |      Return self>value.\n##  |  \n##  |  __iadd__(self, value, /)\n##  |      Implement self+=value.\n##  |  \n##  |  __imul__(self, value, /)\n##  |      Implement self*=value.\n##  |  \n##  |  __init__(self, /, *args, **kwargs)\n##  |      Initialize self.  See help(type(self)) for accurate signature.\n##  |  \n##  |  __iter__(self, /)\n##  |      Implement iter(self).\n##  |  \n##  |  __le__(self, value, /)\n##  |      Return self<=value.\n##  |  \n##  |  __len__(self, /)\n##  |      Return len(self).\n##  |  \n##  |  __lt__(self, value, /)\n##  |      Return self<value.\n##  |  \n##  |  __mul__(self, value, /)\n##  |      Return self*value.\n##  |  \n##  |  __ne__(self, value, /)\n##  |      Return self!=value.\n##  |  \n##  |  __repr__(self, /)\n##  |      Return repr(self).\n##  |  \n##  |  __reversed__(self, /)\n##  |      Return a reverse iterator over the list.\n##  |  \n##  |  __rmul__(self, value, /)\n##  |      Return value*self.\n##  |  \n##  |  __setitem__(self, key, value, /)\n##  |      Set self[key] to value.\n##  |  \n##  |  __sizeof__(self, /)\n##  |      Return the size of the list in memory, in bytes.\n##  |  \n##  |  append(self, object, /)\n##  |      Append object to the end of the list.\n##  |  \n##  |  clear(self, /)\n##  |      Remove all items from list.\n##  |  \n##  |  copy(self, /)\n##  |      Return a shallow copy of the list.\n##  |  \n##  |  count(self, value, /)\n##  |      Return number of occurrences of value.\n##  |  \n##  |  extend(self, iterable, /)\n##  |      Extend list by appending elements from the iterable.\n##  |  \n##  |  index(self, value, start=0, stop=9223372036854775807, /)\n##  |      Return first index of value.\n##  |      \n##  |      Raises ValueError if the value is not present.\n##  |  \n##  |  insert(self, index, object, /)\n##  |      Insert object before index.\n##  |  \n##  |  pop(self, index=-1, /)\n##  |      Remove and return item at index (default last).\n##  |      \n##  |      Raises IndexError if list is empty or index is out of range.\n##  |  \n##  |  remove(self, value, /)\n##  |      Remove first occurrence of value.\n##  |      \n##  |      Raises ValueError if the value is not present.\n##  |  \n##  |  reverse(self, /)\n##  |      Reverse *IN PLACE*.\n##  |  \n##  |  sort(self, /, *, key=None, reverse=False)\n##  |      Sort the list in ascending order and return None.\n##  |      \n##  |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the\n##  |      order of two equal elements is maintained).\n##  |      \n##  |      If a key function is given, apply it once to each list item and sort them,\n##  |      ascending or descending, according to their function values.\n##  |      \n##  |      The reverse flag can be set to sort in descending order.\n##  |  \n##  |  ----------------------------------------------------------------------\n##  |  Class methods defined here:\n##  |  \n##  |  __class_getitem__(...) from builtins.type\n##  |      See PEP 585\n##  |  \n##  |  ----------------------------------------------------------------------\n##  |  Static methods defined here:\n##  |  \n##  |  __new__(*args, **kwargs) from builtins.type\n##  |      Create and return a new object.  See help(type) for accurate signature.\n##  |  \n##  |  ----------------------------------------------------------------------\n##  |  Data and other attributes defined here:\n##  |  \n##  |  __hash__ = None\n```\n:::\n\n\n\n\n```\nHelp on class list in module builtins:\n\nclass list(object)\n |  list(iterable=(), /)\n |  \n |  Built-in mutable sequence.\n |  \n |  If no argument is given, the constructor creates a new empty list.\n |  The argument must be an iterable if specified.\n |  \n |  Methods defined here:\n |  \n |  __add__(self, value, /)\n |      Return self+value.\n |  \n |  __contains__(self, key, /)\n |      Return key in self.\n |  \n |  __delitem__(self, key, /)\n |      Delete self[key].\n |  \n |  __eq__(self, value, /)\n |      Return self==value.\n |  \n |  __ge__(self, value, /)\n |      Return self>=value.\n |  \n |  __getattribute__(self, name, /)\n |      Return getattr(self, name).\n |  \n |  __getitem__(...)\n |      x.__getitem__(y) <==> x[y]\n |  \n |  __gt__(self, value, /)\n |      Return self>value.\n |  \n |  __iadd__(self, value, /)\n |      Implement self+=value.\n |  \n |  __imul__(self, value, /)\n |      Implement self*=value.\n |  \n |  __init__(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  __iter__(self, /)\n |      Implement iter(self).\n |  \n |  __le__(self, value, /)\n |      Return self<=value.\n |  \n |  __len__(self, /)\n |      Return len(self).\n |  \n |  __lt__(self, value, /)\n |      Return self<value.\n |  \n |  __mul__(self, value, /)\n |      Return self*value.\n |  \n |  __ne__(self, value, /)\n |      Return self!=value.\n |  \n |  __repr__(self, /)\n |      Return repr(self).\n |  \n |  __reversed__(self, /)\n |      Return a reverse iterator over the list.\n |  \n |  __rmul__(self, value, /)\n |      Return value*self.\n |  \n |  __setitem__(self, key, value, /)\n |      Set self[key] to value.\n |  \n |  __sizeof__(self, /)\n |      Return the size of the list in memory, in bytes.\n |  \n |  append(self, object, /)\n |      Append object to the end of the list.\n |  \n |  clear(self, /)\n |      Remove all items from list.\n |  \n |  \n |  copy(self, /)\n |      Return a shallow copy of the list.\n |  \n |  count(self, value, /)\n |      Return number of occurrences of value.\n |  \n |  extend(self, iterable, /)\n |      Extend list by appending elements from the iterable.\n |  \n |  index(self, value, start=0, stop=9223372036854775807, /)\n |      Return first index of value.\n |      \n |      Raises ValueError if the value is not present.\n |  \n |  insert(self, index, object, /)\n |      Insert object before index.\n |  \n |  pop(self, index=-1, /)\n |      Remove and return item at index (default last).\n |      \n |      Raises IndexError if list is empty or index is out of range.\n |  \n |  remove(self, value, /)\n |      Remove first occurrence of value.\n |      \n |      Raises ValueError if the value is not present.\n |  \n |  reverse(self, /)\n |      Reverse *IN PLACE*.\n |  \n |  sort(self, /, *, key=None, reverse=False)\n |      Sort the list in ascending order and return None.\n |      \n |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the\n |      order of two equal elements is maintained).\n |      \n |      If a key function is given, apply it once to each list item and sort them,\n |      ascending or descending, according to their function values.\n |      \n |      The reverse flag can be set to sort in descending order.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  __class_getitem__(...) from builtins.type\n |      See PEP 585\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  __new__(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  __hash__ = None\n```\n:::\n\n:::\n\n\n::: example\n### Example: Debugging - Getting help with for loops {-}\n\nSuppose we want to get help on a `for` loop in either language.\n\n::: panel-tabset\n#### R {-}\n\nTo get help in R, we put a `?` in front of a function name to pull up the help file on that function. \nHowever, when we try this with a `for` loop by typing `?for` into the console, we get a + sign. \n\n```\n> ?for\n+ \n```\n\nThat isn't what we expected! The `+` sign indicates that R is still waiting for some input - we haven't given it a complete statement. \nBut why is the statement not complete? \nGoogling for \"?for\" in R gets us something -- a help page about [Getting Help with R](https://www.r-project.org/help.html). \n\nWe get a tiny hint here:\n\n> Standard names in R consist of upper- and lower-case letters, numerals (0-9), underscores (_), and periods (.), and must begin with a letter or a period. To obtain help for an object with a non-standard name (such as the help operator ?), the name must be quoted: for example, help('?') or ?\"?\".\n\nIs it possible that `for` is a non-standard name? Perhaps because it's a reserved word?\nWe can try it out: `?\"for\"` (but first, we need to hit Escape while the console pane is selected, to get out of the incomplete command `?for`). \nAnd, that works! We get a complete statement (a `>` on the next line in the console waiting for more input), and the help page titled \"Control Flow\" pops up. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?\"for\"\n?`for`\n```\n:::\n\n\n\n\nBecause `for` is a reserved word in R, we have to use quotes or backticks (the key above the `TAB` key) to surround the word `for` so that R knows we're talking about the function itself. \nMost other function help can be accessed using `?function_name`. \nThe backtick trick also works for functions that don't start with letters, like `+`.\n\n#### Python {-}\n\nIn python, we try to use `?for` to access the same information (this works for many python functions). \n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n?for # help printed in the help pane\n```\n:::\n\n\n\n\n(You will have to run this in interactive mode for it to work in either language)\n\nWe can also just type in `help` in the python console. \nThe prompt will change to `help> `. \n\nWe then type `for` at the help prompt.\n\n```\nhelp> for\n```\n\nThis gets us:\n\n```\nThe \"for\" statement\n*******************\n\nThe \"for\" statement is used to iterate over the elements of a sequence\n(such as a string, tuple or list) or other iterable object:\n\n   for_stmt ::= \"for\" target_list \"in\" starred_list \":\" suite\n                [\"else\" \":\" suite]\n\nThe \"starred_list\" expression is evaluated once; it should yield an\n*iterable* object.  An *iterator* is created for that iterable. The\nfirst item provided by the iterator is then assigned to the target\nlist using the standard rules for assignments (see Assignment\nstatements), and the suite is executed.  This repeats for each item\nprovided by the iterator.  When the iterator is exhausted, the suite\nin the \"else\" clause, if present, is executed, and the loop\nterminates.\n\nA \"break\" statement executed in the first suite terminates the loop\nwithout executing the \"else\" clause’s suite.  A \"continue\" statement\nexecuted in the first suite skips the rest of the suite and continues\nwith the next item, or with the \"else\" clause if there is no next\nitem.\n\nThe for-loop makes assignments to the variables in the target list.\nThis overwrites all previous assignments to those variables including\nthose made in the suite of the for-loop:\n\n   for i in range(10):\n       print(i)\n       i = 5             # this will not affect the for-loop\n                         # because i will be overwritten with the next\n                         # index in the range\n\nNames in the target list are not deleted when the loop is finished,\nbut if the sequence is empty, they will not have been assigned to at\nall by the loop.  Hint: the built-in type \"range()\" represents\nimmutable arithmetic sequences of integers. For instance, iterating\n\"range(3)\" successively yields 0, 1, and then 2.\n\nChanged in version 3.11: Starred elements are now allowed in the\nexpression list.\n\nRelated help topics: break, continue, while\n```\n\n\n\nOf course, we can also google \"python for loop\" and get [documentation that way](https://wiki.python.org/moin/ForLoop). \nWhen you are just learning how to program, it is often easier to read web documentation that provides lots of examples than the highly technical \"manual\" or \"man\" pages for commands that are shown by default^[In Linux, you access manual pages for commands by running `man <command-name>`. There is an old joke about running the command `man woman`, only to get the response `No manual entry for woman`, because there is no manual page that will help men understand women. Of course, in reality, there is also no command named `woman`...].\nThis is completely normal -- manual pages are written for reference while programming (which assumes you know how to program), and tutorials online are written for people learning how to program. \nReading manual pages is a skill that you develop over time. \n\nw3schools has an excellent python [help page](https://www.w3schools.com/python/python_for_loops.asp) that may be useful as well.\nSearching for help using google also works well, particularly if you know what sites are likely to be helpful, like w3schools and stackoverflow.\nA similar set of pages exists for [R help on basic functions](https://www.w3schools.com/r/r_for_loop.asp)\n:::\n:::\n\n::: callout-note\n## Learn More\n\n[A nice explanation of the difference between an interpreter and a compiler](https://www.py4e.com/html3/01-intro#terminology-interpreter-and-compiler). Both Python and R are interpreted languages that are *compiled* from lower-level languages like C.\n:::\n\n## References {#sec-gen-prog-refs}\n",
    "supporting": [
      "00-intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}