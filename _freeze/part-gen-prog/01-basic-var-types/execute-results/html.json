{
  "hash": "0d7ad27cee11e6b261d3ce1713501073",
  "result": {
    "engine": "knitr",
    "markdown": "# Variables and Basic Data Types {#sec-basic-var-types}\n\n## Objectives {-}\n\n- Know the basic data types and what their restrictions are\n- Know how to test to see if a variable is a given data type\n- Understand the basics of implicit and explicit type conversion\n- Write code that assigns values to variables\n\n## Basic Definitions\n\nFor a general overview, @tomscottWhyTRUETRUE2020 is an excellent introduction to data types:\n\n::: youtube-video-container\n<iframe width=\"640\" height=\"400\" src=\"https://www.youtube.com/embed/6otW6OXjR8c?list=PL96C35uN7xGLLeET0dOWaKHkAlPsrkcha\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; picture-in-picture\" allowfullscreen>\n</iframe>\n:::\n\nLet's start this section with some basic vocabulary.\n\n-   a **value** is a basic unit of stuff that a program works with, like `1`, `2`, `\"Hello, World\"`, and so on.\n-   values have **types** - `2` is an integer, `\"Hello, World\"` is a string (it contains a \"string\" of letters). Strings are in quotation marks to let us know that they are not variable names.\n\nIn most programming languages (including R and python), there are some very basic data types:\n\n-   **logical** or **boolean** - FALSE/TRUE or 0/1 values. Sometimes, boolean is shortened to **bool**\n\n-   **integer** - whole numbers (positive or negative)\n\n-   **double** or **float** - decimal numbers.\n\n    -   **float** is short for floating-point value.\n    -   **double** is a floating-point value with more precision (\"double precision\").[^01-prog-intro-1]\n\n-   **character** or **string** - holds text, usually enclosed in quotes.\n\n\n[^01-prog-intro-1]: This means that doubles take up more memory but can store more decimal places. You don't need to worry about this much in R, and only a little in Python, but in older and more precise languages such as C/C++/Java, the difference between floats and doubles can be important.\n\n::: callout-important\n## Capitalization matters! {.unnumbered}\n\nIn R, boolean values are `TRUE` and `FALSE`, but in Python they are `True` and `False`. Capitalization matters a LOT.\n\nOther things matter too: if we try to write a million, we would write it `1000000` instead of `1,000,000` (in both languages). Commas are used for separating numbers, not for proper spacing and punctuation of numbers. This is a hard thing to get used to but very important -- especially when we start reading in data.\n:::\n\n## Variables\n\nProgramming languages use **variables** - names that refer to values. Think of a variable as a container that holds something - instead of referring to the value, you can refer to the container and you will get whatever is stored inside.\n\n### Assignment\nWe **assign** variables values using the syntax `object_name <- value` (R) or `object_name = value` (python). You can read this as \"object name gets value\" in your head.\n\n::: callout-practice\n\n- DataCamp [Introduction to R](https://app.datacamp.com/learn/courses/free-introduction-to-r) Chapter 1: Intro to basics\n- DataCamp [Introduction to Python for Data Science](https://app.datacamp.com/learn/courses/intro-to-python-for-data-science) Chapter 1: Python Basics\n\n:::\n\nIn R, `<-` is used for assigning a value to a variable. So `x <- \"R is awesome\"` is read \"x gets 'R is awesome'\" or \"x is assigned the value 'R is awesome'\". Technically, you can also use `=` to assign things to variables in R, but most style guides consider this to be poor programming practice, so seriously consider defaulting to `<-`.\n\nIn Python, `=` is used for assigning a value to a variable. This tends to be much easier to say out loud, but lacks any indication of directionality.\n\n::: callout-demo\n#### Demo: Assignment\n::: panel-tabset\n##### R {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessage <- \"So long and thanks for all the fish\"\nyear <- 2025\nthe_answer <- 42L\nearth_demolished <- FALSE\n```\n:::\n\n\n\n\n##### Python {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmessage = \"So long and thanks for all the fish\"\nyear = 2025\nthe_answer = 42\nearth_demolished = False\n```\n:::\n\n\n\n:::\n:::\n\n::: callout-note\nNote that in R, we assign variables values using the `<-` operator, where in Python, we assign variables values using the `=` operator. Technically, `=` will work for assignment in both languages, but `<-` is more common than `=` in R by convention.\n:::\n\nWe can then use the variables - do numerical computations, evaluate whether a proposition is true or false, and even manipulate the content of strings, all by referencing the variable by name.\n\n### Naming Variables\n\n> There are only two hard things in Computer Science: cache invalidation and naming things.\\\n> -- Phil Karlton\n\nObject names must start with a letter and can only contain letters, numbers, `_`, and `.` in R. In Python, object names must start with a letter and can consist of letters, numbers, and `_` (that is, `.` is not a valid character in a Python variable name). While it is technically fine to use uppercase variable names in Python, it's recommended that you use lowercase names for variables (you'll see why later).\n\nWhat happens if we try to create a variable name that isn't valid?\n\nIn both languages, starting a variable name with a number will get you an error message that lets you know that something isn't right - \"unexpected symbol\" in R and \"invalid syntax\" in python.\n\n::: callout-demo\n#### Invalid Names\n::: panel-tabset\n##### R {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1st_thing <- \"check your variable names!\"\n## Error in parse(text = input): <text>:1:2: unexpected symbol\n## 1: 1st_thing\n##      ^\n```\n:::\n\n\n\n\n##### Python {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n1st_thing <- \"check your variable names!\"\n```\n:::\n\n\n\n\nNote: Run the above chunk in your python window - the book won't compile if I set it to evaluate ðŸ˜¥. It generates an error of `SyntaxError: invalid syntax (<string>, line 1)`\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsecond.thing <- \"this isn't valid\"\n## NameError: name 'second' is not defined\n```\n:::\n\n\n\n\nIn python, trying to have a `.` in a variable name gets a more interesting error: \"<first part> is not defined\". This is because in python, some objects have components and methods that can be accessed with `.`. We'll get into this more later, but there is a good reason for python's restriction about not using `.` in variable names.\n:::\n:::\n\nNaming things is difficult! When you name variables, try to make the names descriptive - what does the variable hold? What are you going to do with it? The more (concise) information you can pack into your variable names, the more readable your code will be.\n\n::: callout-learnmore\n#### Learn More\n\n[Why is naming things hard?](https://neilkakkar.com/why-is-naming-things-hard.html) - Blog post by Neil Kakkar\n:::\n\nThere are a few different conventions for naming things that may be useful:\n\n-   `some_people_use_snake_case`, where words are separated by underscores\n-   `somePeopleUseCamelCase`, where words are appended but anything after the first word is capitalized (leading to words with humps like a camel).\n-   `some.people.use.periods` (in R, obviously this doesn't work in python)\n-   A few people mix conventions with `variables_thatLookLike.this` and they are almost universally hated ðŸ‘¿\n\nAs long as you pick ONE naming convention and don't mix-and-match, you'll be fine. It will be easier to remember what you named your variables (or at least guess) and you'll have fewer moments where you have to go scrolling through your script file looking for a variable you named.\n\n## Types\n\n\n::: callout-demo\n### Testing Types\n\nYou can use different functions to test whether a variable has a specific type.\n\n::: panel-tabset\n#### R {- .unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.logical(FALSE)\nis.integer(2L) # by default, R treats all numbers as numeric/decimal values. \n          # The L indicates that we're talking about an integer. \nis.integer(2)\nis.numeric(2)\nis.character(\"Hello, programmer!\")\nis.function(print)\n## [1] TRUE\n## [1] TRUE\n## [1] FALSE\n## [1] TRUE\n## [1] TRUE\n## [1] TRUE\n```\n:::\n\n\n\n\nIn R, you use `is.xxx` functions, where xxx is the name of the type in question.\n\n#### Python {- .unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nisinstance(False, bool)\nisinstance(2, int)\nisinstance(2, (int, float)) # Test for one of multiple types\nisinstance(3.1415, float)\nisinstance(\"This is python code\", str)\n## True\n## True\n## True\n## True\n## True\n```\n:::\n\n\n\n\nIn python, test for types using the `isinstance` function with an argument containing one or more data types in a tuple (`(int, float)` is an example of a tuple - a static set of multiple values).\n\nIf we want to test for whether something is **callable** (can be used like a function), we have to get slightly more complicated:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncallable(print)\n## True\n```\n:::\n\n\n\n\nThis is glossing over some much more technical information about differences between functions and classes (that we haven't covered) [@ryanAnswerHowDetect2009]. \n:::\n:::\n\n::: callout-caution\n### Example: Assignment and Testing Types\n::: panel-tabset\n#### Character {.unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- \"R is awesome\"\ntypeof(x)\n## [1] \"character\"\nis.character(x)\n## [1] TRUE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] FALSE\n```\n:::\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = \"python is awesome\"\ntype(x)\n## <class 'str'>\nisinstance(x, str)\n## True\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## False\nisinstance(x, float)\n## False\n```\n:::\n\n\n\n\n#### Logical {.unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- FALSE\ntypeof(x)\n## [1] \"logical\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] TRUE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] FALSE\n```\n:::\n\n\n\n\nIn R, is possible to use the shorthand `F` and `T`, but be careful with this, because `F` and `T` are not reserved, and other information can be stored within them. See [this discussion](https://twitter.com/tslumley/status/1279870794730893312) for pros and cons of using `F` and `T` as variables vs. shorthand for true and false. [^intro-prog-1]\n\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = False\ntype(x)\n## <class 'bool'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## True\nisinstance(x, int)\n## True\nisinstance(x, float)\n## False\n```\n:::\n\n\n\n\nNote that in python, boolean variables are also integers. If your goal is to test whether something is a T/F value, you may want to e.g. test whether its value is one of 0 or 1, rather than testing whether it is a boolean variable directly, since integers can also function directly as bools in Python.\n\n#### Integer {.unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- 2\ntypeof(x)\n## [1] \"double\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] TRUE\n```\n:::\n\n\n\n\nWait, 2 is an integer, right?\n\n2 is an integer, but in R, values are assumed to be doubles unless specified. So if we want R to treat 2 as an integer, we need to specify that it is an integer specifically.\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- 2L # The L immediately after the 2 indicates that it is an integer.\ntypeof(x)\n## [1] \"integer\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] TRUE\nis.double(x)\n## [1] FALSE\nis.numeric(x)\n## [1] TRUE\n```\n:::\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = 2\ntype(x)\n## <class 'int'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## True\nisinstance(x, float)\n## False\n```\n:::\n\n\n\n\n#### Double {.unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- 2.45\ntypeof(x)\n## [1] \"double\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] TRUE\nis.numeric(x)\n## [1] TRUE\n```\n:::\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = 2.45\ntype(x)\n## <class 'float'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## False\nisinstance(x, float)\n## True\n```\n:::\n\n\n\n\n#### Numeric {.unnumbered}\n\nA fifth common \"type\"[^intro-prog-2], `numeric` is really the union of two types: integer and double, and you may come across it when using `str()` or `mode()`, which are similar to `typeof()` but do not quite do the same thing.\n\nThe `numeric` category exists because when doing math, we can add an integer and a double, but adding an integer and a string is ... trickier. Testing for numeric variables guarantees that we'll be able to do math with those variables. `is.numeric()` and `as.numeric()` work as you would expect them to work.\n\nThe general case of this property of a language is called **implicit type conversion** - that is, R will implicitly (behind the scenes) convert your integer to a double and then add the other double, so that the result is unambiguously a double.\n:::\n\n:::\n\n[^intro-prog-1]: There is also an [R package dedicated to pure evil](https://purrple.cat/blog/2017/05/28/turn-r-users-insane-with-evil/) that will set F and T randomly on startup. Use this information wisely.\n\n[^intro-prog-2]: `numeric` is not really a type, it's a mode. Run `?mode` for more information.\n\n## Type Conversions {#sec-type-conversions}\n\nProgramming languages will generally work hard to seamlessly convert variables to different types. \nThis is called **implicit** type casting - the computer implicitly changes the variable type to avoid a conflict.\n\n::: callout-demo\n### Implicit Type Conversion\n::: panel-tabset\n\n#### R {- .unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nTRUE + 2\n## [1] 3\n\n2L + 3.1415\n## [1] 5.1415\n\n\"abcd\" + 3\n## Error in \"abcd\" + 3: non-numeric argument to binary operator\n```\n:::\n\n\n\n\n#### Python {- .unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nTrue + 2\n## 3\n\nint(2) + 3.1415\n## 5.141500000000001\n\n\"abcd\" + 3\n## TypeError: can only concatenate str (not \"int\") to str\n```\n:::\n\n\n\n:::\n\n\nThis conversion doesn't always work - there's no clear way to make \"abcd\" into a number we could use in addition. \nSo instead, R or python will issue an error. \nThis error pops up frequently when something went wrong with data import and all of a sudden you just tried to take the mean of a set of string/character variables. Whoops.\n:::\n\nWhen you want to, you can also use `as.xxx()` to make the type conversion **explicit**. So, the analogue of the code above, with explicit conversions would be:\n\n::: callout-demo\n### Explicit Type Conversion\n::: panel-tabset\n\n#### R {- .unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nas.double(TRUE) + 2\n## [1] 3\n\nas.double(2L) + 3.1415\n## [1] 5.1415\n\nas.numeric(\"abcd\") + 3\n## [1] NA\n```\n:::\n\n\n\n\n#### Python {- .unnumbered}\n\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nint(True) + 2\n## 3\n\nfloat(2) + 3.1415\n## 5.141500000000001\n\nfloat(\"abcd\") + 3\n## ValueError: could not convert string to float: 'abcd'\n\nimport pandas as pd # Load pandas library\npd.to_numeric(\"abcd\", errors = 'coerce') + 3\n## np.float64(nan)\n```\n:::\n\n\n\n:::\n\n\nWhen we make our intent explicit (convert \"abcd\" to a numeric variable) we get an NA - a missing value - in R. In Python, we get a more descriptive error by default, but we can use the `pandas` library (which adds some statistical functionality) to get a similar result to the result we get in R.\n\nThere's still no easy way to figure out where \"abcd\" is on a number line, but our math will still have a result - `NA + 3` is `NA`.\n:::\n\n## What Type is it?\n\nIf you don't know what type a value is, both R and python have functions to help you with that.\n\n::: callout-demo\n### Determining Variable Types\n::: panel-tabset\n\n#### R {- .unnumbered}\n\nIf you are unsure what the type of a variable is, use the `typeof()` function to find out.\n\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nw <- \"a string\"\nx <- 3L\ny <- 3.1415\nz <- FALSE\n\ntypeof(w)\n## [1] \"character\"\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"double\"\ntypeof(z)\n## [1] \"logical\"\n```\n:::\n\n\n\n\n#### Python {- .unnumbered}\n\nIf you are unsure what the type of a variable is, use the `type()` function to find out.\n\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nw = \"a string\"\nx = 3\ny = 3.1415\nz = False\n\ntype(w)\n## <class 'str'>\ntype(x)\n## <class 'int'>\ntype(y)\n## <class 'float'>\ntype(z)\n## <class 'bool'>\n```\n:::\n\n\n\n\n:::\n:::\n\n::: callout-tip\n## Try It Out: Variables and Types \n\n::: panel-tabset\n\n### R {- .unnumbered}\n\n1.  Create variables `string`, `integer`, `decimal`, and `logical`, with types that match the relevant variable names.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- \ninteger <- \ndecimal <- \nlogical <- \n```\n:::\n\n\n\n\n2.  Can you get rid of the error that occurs when this chunk is run?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical + decimal\ninteger + decimal\nstring + integer\n```\n:::\n\n\n\n\n3.  What happens when you add string to string? logical to logical?\n\n### Python {- .unnumbered}\n\n1.  Create variables `string`, `integer`, `decimal`, and `logical`, with types that match the relevant variable names.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nstring = \ninteger = \ndecimal = \nlogical = \n```\n:::\n\n\n\n\n2.  Can you get rid of the error that occurs when this chunk is run?\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlogical + decimal\ninteger + decimal\nstring + integer\n```\n:::\n\n\n\n\n3.  What happens when you add string to string? logical to logical?\n\n### R Solution {- .unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- \"hi, I'm a string\"\ninteger <- 4L\ndecimal <- 5.412\nlogical <- TRUE\n\nlogical + decimal\n## [1] 6.412\ninteger + decimal\n## [1] 9.412\nas.numeric(string) + integer\n## [1] NA\n\n\"abcd\" + \"efgh\"\n## Error in \"abcd\" + \"efgh\": non-numeric argument to binary operator\nTRUE + TRUE\n## [1] 2\n```\n:::\n\n\n\n\nIn R, adding a string to a string creates an error (\"non-numeric argument to binary operator\"). Adding a logical to a logical, e.g. TRUE + TRUE, results in 2, which is a numeric value.\n\nTo concatenate strings in R (like the default behavior in python), we would use the `paste0` function: `paste0(\"abcd\", \"efgh\")`, which returns abcdefgh.\n\n### Python Solution {- .unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\nstring = \"hi, I'm a string\"\ninteger = 4\ndecimal = 5.412\nlogical = True\n\nlogical + decimal\n## 6.412\ninteger + decimal\n## 9.411999999999999\npd.to_numeric(string, errors='coerce') + integer\n## np.float64(nan)\n\n\"abcd\" + \"efgh\"\n## 'abcdefgh'\nTrue + True\n## 2\n```\n:::\n\n\n\n\nIn Python, when a string is added to another string, the two strings are **concatenated**. This differs from the result in R, which is a \"non-numeric argument to binary operator\" error.\n\n:::\n\n:::\n\n## References  {#sec-basic-var-types-refs}\n\n",
    "supporting": [
      "01-basic-var-types_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}