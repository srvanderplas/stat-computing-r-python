{
  "hash": "0d5125a29c5307fdd464ef4ad9b789a0",
  "result": {
    "engine": "knitr",
    "markdown": "# Control Structures {#sec-control-struct}\n\nControl structures are statements in a program that determine when code is evaluated (and how many times it might be evaluated). \nThere are two main types of control structures: if-statements and loops.\n\n## Objectives {-}\n\n- Understand how to use conditional statements\n- Understand how conditional statements are evaluated by a program\n- Use program flow diagrams to break a problem into parts and evaluate how a program will execute\n- Understand how to use loops\n- Select the appropriate type of loop for a problem\n\n\n## Mindset\nBefore we start on the types of control structures, let's get in the right mindset. \nWe're all used to \"if-then\" logic, and use it in everyday conversation, but computers require another level of specificity when you're trying to provide instructions.\n\nCheck out this video of the classic \"make a peanut butter sandwich instructions challenge\":\n\n::: youtube-video-container\n\n\n\n{{< video https://www.youtube.com/watch?v=FN2RM-CHkuI >}}\n\n\n\n\n\n:::\n\nHere's another example:\n\n!['If you're done being pedantic, we should get dinner.' 'You did it again!' 'No, I didn't.' Image from Randal Munroe, xkcd.com, available under a [CC-By 2.5 license](https://creativecommons.org/licenses/by-nc/2.5/).](../images/gen-prog/conditionals.png)\n\nThe key takeaways from these bits of media are that you should read this section with a focus on exact precision - state *exactly* what you mean, and the computer will do what you say. \nIf you instead expect the computer to get what you mean, you're going to have a bad time.\n\n## Conditional Statements\n\nConditional statements determine if code is evaluated.\n\nThey look like this:\n\n    if (condition)\n      then\n        (thing to do)\n      else\n        (other thing to do)\n\nThe else (other thing to do) part may be omitted.\n\nWhen this statement is read by the computer, the computer checks to see if condition is true or false. \nIf the condition is true, then (thing to do) is also run. \nIf the condition is false, then (other thing to do) is run instead.\n\n::: demo\n### Demo: Conditional Statements\n\n::: panel-tabset\n### R {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\ny <- 1\n\nif (x > 2) { \n  y <- 8\n} else {\n  y <- 4\n}\n\nprint(paste(\"x =\", x, \"; y =\", y))\n## [1] \"x = 3 ; y = 8\"\n```\n:::\n\n\n\n\nIn R, the logical condition after `if` must be in parentheses. \nIt is common to then enclose the statement to be run if the condition is true in `{}` so that it is clear what code matches the if statement. \nYou can technically put the condition on the line after the `if (x > 2)` line, and everything will still work, but then it gets hard to figure out what to do with the else statement - it technically would also go on the same line, and that gets hard to read.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 3\ny <- 1\n\nif (x > 2) y <- 8 else y <- 4\n\nprint(paste(\"x =\", x, \"; y =\", y))\n## [1] \"x = 3 ; y = 8\"\n```\n:::\n\n\n\n\nSo while the 2nd version of the code technically works, the first version with the brackets is much easier to read and understand. Please try to emulate the first version!\n\n### Python {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 3\ny = 1\n\nif x > 2:\n  y = 8\nelse:\n  y = 4\n\nprint(\"x =\", x, \"; y =\", y)\n## x = 3 ; y = 8\n```\n:::\n\n\n\n\nIn python, all code grouping is accomplished with spaces instead of with brackets. \nSo in python, we write our if statement as `if x > 2:` with the colon indicating that what follows is the code to evaluate. \nThe next line is indented with 2 spaces to show that the code on those lines belongs to that if statement. \nThen, we use the else: statement to provide an alternative set of code to run if the logical condition in the if statement is false. \nAgain, we indent the code under the else statement to show where it \"belongs\".\n\n\n<!-- https://www.py4e.com/html3/03-conditional -->\n:::\n:::\n\n::: callout-warning\nPython will throw errors if you mess up the spacing. \nThis is one thing that is very annoying about Python... but it's a consequence of trying to make the code more readable.\n:::\n\n### Representing Conditional Statements as Diagrams\n\nA common way to represent conditional logic is to draw a flow chart diagram.\n\nIn a flow chart, conditional statements are represented as diamonds, and other code is represented as a rectangle. \nYes/no or True/False branches are labeled. \nTypically, after a conditional statement, the program flow returns to a single point.\n\n![Program flow diagram outline of a simple if/else statement](../images/gen-prog/flow-chart1.png)\n\n### Chaining Conditional Statements: Else-If\n\nIn many cases, it can be helpful to have a long chain of conditional statements describing a sequence of alternative statements.\n\nWhile different languages have different conventions for this, it's helpful to conceptualize the if-else-if-else pattern as a series of binary choices evaluated in sequence. \nI like to imagine a superhero trying to make contingency plans for a battle with their nemesis - if they try this, then I'll do this, and if that doesn't work, then I'll do this other thing.\nThe important thing is to make sure that all possible outcomes are covered, because if there is an edge case that isn't covered, it will inevitably lead to a bug that you'll have to track down later.\n\n::: example\n#### Example - Conditional Evaluation {-}\n\nSuppose I want to determine what categorical age bracket someone falls into based on their numerical age. \nAll of the bins are mutually exclusive - you can't be in the 25-40 bracket and the 41-55 bracket.\n\n::: panel-tabset\n##### Program Flow Map {.unnumbered}\n\n![Program flow map for a series of mutually exclusive categories. If our goal is to take a numeric age variable and create a categorical set of age brackets, such as \\<18, 18-25, 26-40, 41-55, 56-65, and \\>65, we can do this with a series of if-else statements chained together. Only one of the bracket assignments is evaluated, so it is important to place the most restrictive condition first.](../images/gen-prog/age-category-prog-flow.png)\n\nThe important thing to realize when examining this program flow map is that if `age <= 18` is true, then **none of the other conditional statements even get evaluated**. \nThat is, once a statement is true, none of the other statements matter. \nBecause of this, it is important to place the most restrictive statement first.\n\n![Program flow map for a series of mutually exclusive categories, emphasizing that only some statements are evaluated. When age = 40, only (age \\<= 18), (age \\<= 25), and (age \\<= 40) are evaluated conditionally. Of the assignment statements, only bracket = '26-40' is evaluated when age = 40.](../images/gen-prog/age-category-prog-flow2.png)\n\nIf for some reason you wrote your conditional statements in the wrong order, the wrong label would get assigned:\n\n![Program flow map for a series of mutually exclusive categories, with category labels in the wrong order - \\<40 is evaluated first, and so \\<= 25 and \\<= 18 will never be evaluated and the wrong label will be assigned for anything in those categories.](../images/gen-prog/age-category-prog-flow3.png)\n\nIn code, we would write this statement using `else-if` (or `elif`) statements.\n\n##### R {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- 40 # change this as you will to see how the code works\n\nif (age < 18) {\n  bracket <- \"<18\"\n} else if (age <= 25) {\n  bracket <- \"18-25\"\n} else if (age <= 40) {\n  bracket <- \"26-40\"\n} else if (age <= 55) {\n  bracket <- \"41-55\" \n} else if (age <= 65) {\n  bracket <- \"56-65\"\n} else {\n  bracket <- \">65\"\n}\n\nbracket\n## [1] \"26-40\"\n```\n:::\n\n\n\n\n##### Python {.unnumbered}\n\nPython uses `elif` as a shorthand for `else if` statements. As always, indentation/white space in python matters. If you put an extra blank line between two elif statements, then the interpreter will complain. If you don't indent properly, the interpreter will complain.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nage = 40 # change this to see how the code works\n\nif age < 18:\n  bracket = \"<18\"\nelif age <= 25:\n  bracket = \"18-25\"\nelif age <= 40:\n  bracket = \"26-40\"\nelif age <= 55:\n  bracket = \"41-55\"\nelif age <= 65:\n  bracket = \"56-65\"\nelse:\n  bracket = \">65\"\n  \nbracket\n## '26-40'\n```\n:::\n\n\n\n:::\n:::\n\n\n::: diy\n#### Try It Out - Chained If/Else Statements\n\n::: panel-tabset\n##### Problem {.unnumbered}\n\nThe US Tax code has brackets, such that the first \\$10,275 of your income is taxed at 10%, anything between \\$10,275 and \\$41,775 is taxed at 12%, and so on.\n\nHere is the table of tax brackets for single filers in 2022:\n\n| rate | Income                 |\n|------|------------------------|\n| 10%  | \\$0 to \\$10,275        |\n| 12%  | \\$10,275 to \\$41,775   |\n| 22%  | \\$41,775 to \\$89,075   |\n| 24%  | \\$89,075 to \\$170,050  |\n| 32%  | \\$170,050 to \\$215,950 |\n| 35%  | \\$215,950 to \\$539,900 |\n| 37%  | \\$539,900 or more      |\n\nNote: For the purposes of this problem, we're ignoring the personal exemption and the standard deduction, so we're already simplifying the tax code.\n\nWrite a set of if statements that assess someone's income and determine what their overall tax rate is.\n\nHint: You may want to keep track of how much of the income has already been taxed in a variable and what the total tax accumulation is in another variable.\n\n\n<!-- First, let's start by looking at a graph of the practical implication of taxing things using brackets. This graph shows the amount in each bracket as well as the amount of taxes paid. -->\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n##### Flow Map\n\n![The control flow diagram for the tax brackets](../images/gen-prog/tax-brackets.png)\n\nControl flow diagrams can be extremely helpful when figuring out how programs work (and where gaps in your logic are when you're debugging). \nIt can be very helpful to map out your program flow as you're untangling a problem.\n\n\n##### R Solution {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start with total income\nincome <- 200000\n\n# x will hold income that hasn't been taxed yet\nx <- income\n# y will hold taxes paid\ny <- 0\n\nif (x <= 10275) {\n  y <- x*.1 # tax paid\n  x <- 0 # All money has been taxed\n} else {\n  y <- y + 10275 * .1\n  x <- x - 10275 # Money remaining that hasn't been taxed\n}\n\nif (x <= (41775 - 10275)) {\n  y <- y + x * .12\n  x <- 0\n} else {\n  y <- y + (41775 - 10275) * .12\n  x <- x - (41775 - 10275) \n}\n\nif (x <= (89075 - 41775)) {\n  y <- y + x * .22\n  x <- 0\n} else {\n  y <- y + (89075 - 41775) * .22\n  x <- x - (89075 - 41775)\n}\n\nif (x <= (170050 - 89075)) {\n  y <- y + x * .24\n  x <- 0\n} else {\n  y <- y + (170050 - 89075) * .24\n  x <- x - (170050 - 89075)\n}\n\nif (x <= (215950 - 170050)) {\n  y <- y + x * .32\n  x <- 0\n} else {\n  y <- y + (215950 - 170050) * .32\n  x <- x - (215950 - 170050)\n}\n\nif (x <= (539900 - 215950)) {\n  y <- y + x * .35\n  x <- 0\n} else {\n  y <- y + (539900 - 215950) * .35\n  x <- x - (539900 - 215950)\n}\n\nif (x > 0) {\n  y <- y + x * .37\n}\n\n\nprint(paste(\"Total Tax Rate on $\", income, \" in income = \", round(y/income, 4)*100, \"%\"))\n## [1] \"Total Tax Rate on $ 2e+05  in income =  22.12 %\"\n```\n:::\n\n\n\n\n##### Python Solution {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Start with total income\nincome = 200000\n\n# untaxed will hold income that hasn't been taxed yet\nuntaxed = income\n# taxed will hold taxes paid\ntaxes = 0\n\nif untaxed <= 10275:\n  taxes = untaxed*.1 # tax paid\n  untaxed = 0 # All money has been taxed\nelse:\n  taxes = taxes + 10275 * .1\n  untaxed = untaxed - 10275 # money remaining that hasn't been taxed\n\nif untaxed <= (41775 - 10275):\n  taxes = taxes + untaxed * .12\n  untaxed = 0\nelse:\n  taxes = taxes + (41775 - 10275) * .12\n  untaxed = untaxed - (41775 - 10275) \n\n\nif untaxed <= (89075 - 41775):\n  taxes = taxes + untaxed * .22\n  untaxed = 0\nelse: \n  taxes = taxes + (89075 - 41775) * .22\n  untaxed = untaxed - (89075 - 41775)\n\nif untaxed <= (170050 - 89075):\n  taxes = taxes + untaxed * .24\n  untaxed = 0\nelse: \n  taxes = taxes + (170050 - 89075) * .24\n  untaxed = untaxed - (170050 - 89075)\n\nif untaxed <= (215950 - 170050):\n  taxes = taxes + untaxed * .32\n  untaxed = 0\nelse:\n  taxes = taxes + (215950 - 170050) * .32\n  untaxed = untaxed - (215950 - 170050)\n\nif untaxed <= (539900 - 215950):\n  taxes = taxes + untaxed * .35\n  untaxed = 0\nelse: \n  taxes = taxes + (539900 - 215950) * .35\n  untaxed = untaxed - (539900 - 215950)\n\n\nif untaxed > 0:\n  taxes = taxes + untaxed * .37\n\n\n\nprint(\"Total Tauntaxed Rate on $\", income, \" in income = \", round(taxes/income, 4)*100, \"%\")\n## Total Tauntaxed Rate on $ 200000  in income =  22.12 %\n```\n:::\n\n\n\n\nThere are better ways to represent this calculation that depend on concepts like vectors or loops -- see @sec-cond-efficiency for details. \nAny time you find yourself copy-pasting code and changing values, you should consider using vectorized code, a loop, or eventually, a function instead. It's less typing and easier to maintain.\n\n:::\n:::\n\n:::: {.advanced collapse=true}\n### Compact Chained Conditionals\n\n::: callout-caution\nThe case statement is relatively new in Python (added in 3.10), so if you are using an older version of Python, you will not be able to make the code in this section work.\n:::\n\nThe code to implement a long series of if-else statements can get rather long and hard to follow. \nThis complexity is particularly unnecessary when all of the if() statements are related to one variable, and it's even more unnecessary when that variable has a fixed number of values that correspond to different actions. \n\nThe **switch statement** (implemented using `match` and `case` in Python, `case_when` in `dplyr`, and `switch` in base R) is a way to make long sets of conditionals clearer and more compact. \n\nA general switch statement looks like this:\n\n```\nswitch (test-value) {\n  case (first-value):\n    <do something>\n  case (second-value):\n    <do something else>\n  default-value:\n    <do the default thing>\n}\n```\n\nEssentially, in a switch statement, you look for one of a finite list of values, and do something based on which value is true **first** in the sequence. \nIdeally the values first-value and second-value are completely disjoint, but that doesn't always happen -- however, in a switch statement, as in chained if-statements, the first value to be TRUE causes subsequent statements not to be executed at all, which essentially means that subsequent statements are implicitly of the form `second-value and NOT first-value`, `third-value and NOT second-value and NOT first-value`, and so on.\n\n\nNote that any series of chained if statements based on a single quantitative variable can be converted to allow the use of a switch statement by assigning labels to each different group of conditions and then using a switch statement to evaluate the variable holding the labels. \n\n\nFor each implementation, we'll look at how we might do something based on a coffee order size, using Starbucks size labels (which I've never gotten straight, but I don't drink a ton of coffee). \n\n::: panel-tabset\n#### R (base) {-}\n\nThe `switch` statement in base R works differently depending on whether the first argument is a character string or a number. \nIf the first argument is a number, it's converted to an integer. \nFactors (sequential integers with labels) should be manually converted to character variables or integers; a switch statement with a factor as the first argument will issue a warning. \nIf the first argument is a character vector, then the remaining arguments should be named according to the possible values of that character vector. \nAn additional unnamed argument should be included at the end to handle any unaccounted for cases.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsize <- c(\"short\", \"tall\", \"grande\", \"venti\", \"trenta\")\n\nsizefac <- factor(size, levels = size, ordered = T)\n\nsize[1]\n## [1] \"short\"\nsizefac[1]\n## [1] short\n## Levels: short < tall < grande < venti < trenta\n\nswitch(\n  size[3],\n  \"short\" = 8, \n  \"tall\" = 12,\n  \"grande\" = 16,\n  \"venti\" = 20,\n  \"trenta\" = 30,\n  NA) # default value is unnamed\n## [1] 16\n\n\nswitch(\n  sizefac[3],\n  \"short\" = 8, \n  \"tall\" = 12,\n  \"grande\" = 16,\n  \"venti\" = 20,\n  \"trenta\" = 30, \n  NA) \n## [1] 16\n# Warning if you use a factor without converting\n# to a character variable\n\n\nswitch(as.numeric(sizefac[3]), 8, 12, 16, 20, 30) \n## [1] 16\n# If an integer, all arguments must be unnamed\n# No default value is possible\n```\n:::\n\n\n\n\n#### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nsize = [\"short\", \"tall\", \"grande\", \"venti\", \"trenta\"]\n\nmatch size[2]:\n  case \"short\": 8\n  case \"tall\": 12\n  case \"grande\": 16\n  case \"venti\": 20\n  case \"trenta\": 30\n  case _: pd.NA\n## 16\n```\n:::\n\n\n\n\n#### `case_match` (R-dplyr) {-}\n\nThe approach taken by the `case_match` function is similar to that in python, but it's vectorized, which is convenient -- we don't have to loop over the full vector to get the size in ounces for each cup.\n\n`case_match` also works with factors without requiring an explicit type conversion. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nsize <- c(\"short\", \"tall\", \"grande\", \"venti\", \"trenta\")\n\nsizefac <- factor(size, levels = size, ordered = T)\n\ncase_match(\n  size,\n  \"short\" ~ 8, \n  \"tall\" ~ 12, \n  \"grande\" ~ 16, \n  \"venti\" ~ 20, \n  \"trenta\" ~ 30, \n  .default = NA\n)\n## [1]  8 12 16 20 30\n\ncase_match(\n  sizefac,\n  \"short\" ~ 8, \n  \"tall\" ~ 12, \n  \"grande\" ~ 16, \n  \"venti\" ~ 20, \n  \"trenta\" ~ 30, \n  .default = NA\n)\n## [1]  8 12 16 20 30\n```\n:::\n\n\n\n\nBut, `case_match` does something else that's somewhat unique -- it allows you to specify multiple labels that correspond to the same output value. \nSuppose our Starbucks is out of 8 and 30 oz cups, and they are thus offering free upgrades from short to tall orders, while not offering any trenta orders.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_match(\n  sizefac,\n  c(\"short\",\"tall\") ~ 12, \n  \"grande\" ~ 16, \n  \"venti\" ~ 20, \n  .default = NA\n)\n## [1] 12 12 16 20 NA\n```\n:::\n\n\n\n\nThis setup allows us to collapse categories easily while still keeping the basic syntax and options for order sizes the same. \n\n\n:::\n\n\n#### `case_when` in `dplyr` {-}\n\n`dplyr` also includes an additional function that is somewhat different than the canonical `switch` statement: `case_when`. \n`case_when` uses logical expressions on one side, making it much closer to a direct equivalent of an if-then-else-if... chain of expressions. \nThe first expression to evaluate to TRUE is what determines the output.\n\n::: diy\n##### Try It Out: Income Taxes {-}\n\n::: panel-tabset\n\n###### Problem\n\nLet's consider our income tax example from before. Try to write the tax calculation out using a case-when statement in R. Can you come up with an equivalent formulation in Python by defining an intermediate labeled variable? \n\n###### R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start with total income\nincome <- 200000\n\n# x will hold income that hasn't been taxed yet\nx <- income\n# y will hold taxes paid\ny <- case_when(\n  x <= 10275  ~ x*.1,\n  x <= 41775  ~ 10275*.10 +         (x-10275)*.12,\n  x <= 80975  ~ 10275*.10 +     (41775-10275)*.12 + \n          (x - 41775)*.22,\n  x <= 170050 ~ 10275*.10 +     (41775-10275)*.12 + \n      (80975 - 41775)*.22 +       (x - 80975)*.24,\n  x <= 215950 ~ 10275*.10 +     (41775-10275)*.12 + \n      (80975 - 41775)*.22 +  (170050 - 80975)*.24 +\n         (x - 170050)*.32,\n  x <= 539900 ~ 10275*.10 +     (41775-10275)*.12 + \n      (80975 - 41775)*.22 +  (170050 - 80975)*.24 +\n    (215950 - 170050)*.32 +        (x-215950)*.35,\n  .default =    10275*.10 +     (41775-10275)*.12 + \n      (80975 - 41775)*.22 +  (170050 - 80975)*.24 +\n    (215950 - 170050)*.32 + (539900 - 215950)*.35 + \n       (x - 539900) * .37\n)\n\nprint(paste(\"Total Tax Rate on $\", income, \" in income = \", round(y/income, 4)*100, \"%\"))\n## [1] \"Total Tax Rate on $ 2e+05  in income =  22.2 %\"\n```\n:::\n\n\n\n\n\nThis is a much more concise set of statements that are still pretty clear. \nNote that we've had to refactor the calculation, so that each calculation happens separately rather than being cumulative, but that isn't so terrible. \n\n###### Python\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Start with total income\nincome = 200000\n\n# x will hold income that hasn't been taxed yet\nx = income\n\nbrackets = np.array([10275, 41775, 80975, 170050, 215950, 539900])\nbrackets = brackets.astype('int32')\nbracket_labels = np.array([str(i) for i in brackets])\nbracket_labels = np.append(bracket_labels, \"Inf\")\nbrackets = np.append(brackets, np.inf)\n\nmatch bracket_labels[brackets >= x][0]:\n  case \"10275\": \n    y = x*.1\n  case \"41775\":\n    y = (x-10275)*.12 + 10275*.1\n  case \"80975\":\n    y = (x-41775)*.22 + (41775-10275)*.12 + 10275*.1\n  case \"170050\":\n    y = (x-80975)*.24 + (80975-41775)*.22 + (41775-10275)*.12 + 10275*.1\n  case \"215950\":\n    y = (x-170050)*.32 + (170050-80975)*.24 + (80975-41775)*.22 + (41775-10275)*.12 + 10275*.1\n  case \"539900\":\n    y = (x-215950)*.35 + (215950-170050)*.32 + (170050-80975)*.24 + (80975-41775)*.22 + (41775-10275)*.12 + 10275*.1\n  case _:\n    y = (x-539900)*.37 + (539900-215950)*.35 + (215950-170050)*.32 + (170050-80975)*.24 + (80975-41775)*.22 + (41775-10275)*.12 + 10275*.1\n\ny\n## 44393.5\n\nprint(\"Total Tax Rate on $\" + str(income) + \" in income = \" + str(round(y/income, 4)*100) + \"%\")\n## Total Tax Rate on $200000 in income = 22.2%\n```\n:::\n\n\n\n\nTo be able to use a python case statement, we first have to decide on some labels that are mutually exclusive and indicate which set of tax rates to apply. \nIn this case, I've decided to use the next bracket above the total income level as the label, which tells me that I don't have to worry about any income over the labeled level. \n:::\n\n:::\n::::\n\n:::: {.advanced collapse=true}\n### Computational Efficiency and Conditionals {#sec-cond-efficiency}\n\nIn some cases, it is possible to replace conditional sequences with carefully constructed vectorized calculations. \nThis is much more efficient (especially in R, where vectorization is one primary way to decrease evaluation time) and can be easier to read and understand as well. \n\n::: demo\n#### Demo: Tax Brackets without Conditionals {-}\n\nWe can use vectorized calculations and make the tax calculations even more succinct, eliminating the need for any if-statements (or similar constructs).  \n\n::: panel-tabset\n##### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrackets <- c(    0, 10275, 41775, 80975, 170050, 215950, 539900, Inf)\nrates <-    c(   .1,   .12,   .22,    .24,    .32,   .35,    .37)\n\nsum(-diff(pmax(0, x-brackets)) * rates)\n## [1] 44393.5\n```\n:::\n\n\n\n##### Python {-}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Start with total income\nx = 200000\n\nbrackets = np.array([    0, 10275, 41775, 80975, 170050, 215950, 539900, np.inf])\nrates    = np.array([   .1,   .12,   .22,    .24,    .32,   .35,    .37])\n\nnp.sum(-np.diff(np.maximum(0, x - brackets))*rates)\n## np.float64(44393.5)\n```\n:::\n\n\n\n\n:::\n\n\nThis is the simplest refactoring of this problem, but it's also less directly comprehensible. \nIt will evaluate much more quickly than the conditional formulations in computer time, but the programmer has to go through and understand what is happening, which isn't always easy to do, particularly when you didn't write the code. \n\n::: column-margin\nSometimes, it's that you wrote the code years ago, and past you was invariably smarter *and* dumber than you are currently.  ![I have a t-shirt that has something like this on it, and I'm amazed at how frequently it's true.](../images/gen-prog/debugging-classic-mystery-game.jpg){fig-alt=\"Debugging: The classic mystery game where you are the detective, the victim, and the murderer. Shows dice and game pieces similar to those in the board game Clue.\"}  \n:::\n\nHere is a longer sequence of code that performs the same calculations, with variables named descriptively.\n\n::: panel-tabset\n##### R {-}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrackets <- c(    0, 10275, 41775, 80975, 170050, 215950, 539900, Inf) # <1>\nrates <-    c(   .1,   .12,   .22,    .24,    .32,   .35,    .37)\n\namount_above_bracket <- x - brackets  # <2>\namount_above_bracket\n\ncumulative_amount_subject_to_rate <- pmax(0, amount_above_bracket)  # <3>\ncumulative_amount_subject_to_rate\n\namount_subject_to_rate <- -diff(cumulative_amount_subject_to_rate) # <4>\ntaxes_per_level <- amount_subject_to_rate*rates # <5>\n\n# Display calculation in table\nrbind(amount = amount_subject_to_rate, rate = rates, tax_at_level = taxes_per_level)\n\ntotal_taxes <- sum(taxes_per_level) # <6>\ntotal_taxes\n## [1]  200000  189725  158225  119025   29950  -15950 -339900    -Inf\n## [1] 200000 189725 158225 119025  29950      0      0      0\n##                 [,1]     [,2]     [,3]     [,4]     [,5] [,6] [,7]\n## amount       10275.0 31500.00 39200.00 89075.00 29950.00 0.00 0.00\n## rate             0.1     0.12     0.22     0.24     0.32 0.35 0.37\n## tax_at_level  1027.5  3780.00  8624.00 21378.00  9584.00 0.00 0.00\n## [1] 44393.5\n```\n:::\n\n\n\n1. `brackets` defines the cutoffs for the different hierarchical tax rates, including the `[539900, Inf)` implicit bracket\n2. `x - brackets` calculates the amount of income taxed at or above each rate\n3. `pmax(0, x-brackets)` does not allow the values to go below 0, so that we're not paying negative taxes (though that would be nice, and some tax credits actually work that way)\n4. `diff(...)` subtracts value 1 from value 2, value 2 from value 3, and so on, shortening the vector by 1. This produces negative values in this case, so we have to multiply by -1 to get them back to positive values (we could also reverse the vector, diff, and then reverse again, e.g. `sum(rev(diff(pmax(0, rev(x-brackets)))) * rates)`).\n5. Then, we can multiply our values by their corresponding rates (`-diff(pmax(0, x-brackets))*rates`). \n6. Finally, we add up the values (`sum`) in the vector to get the total tax burden for someone making \\$200,000 per year. \n\n##### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n# Start with total income\nx = 200000\n\nbrackets = np.array([    0, 10275, 41775, 80975, 170050, 215950, 539900, np.inf]) # <1>\nrates    = np.array([   .1,   .12,   .22,    .24,    .32,   .35,    .37])\n\namount_above_bracket = x - brackets  # <2>\namount_above_bracket\n\ncumulative_amount_subject_to_rate = np.maximum(0, amount_above_bracket)  # <3>\ncumulative_amount_subject_to_rate\n\namount_subject_to_rate = -np.diff(cumulative_amount_subject_to_rate) # <4>\ntaxes_per_level = amount_subject_to_rate*rates # <5>\n\n# Display calculation in table\npd.DataFrame({\"amount\" : amount_subject_to_rate, \"rate\" : rates, \"tax_at_level\" : taxes_per_level})\n\ntotal_taxes = sum(taxes_per_level) # <6>\ntotal_taxes\n## array([ 200000.,  189725.,  158225.,  119025.,   29950.,  -15950.,\n##        -339900.,     -inf])\n## array([200000., 189725., 158225., 119025.,  29950.,      0.,      0.,\n##             0.])\n##     amount  rate  tax_at_level\n## 0  10275.0  0.10        1027.5\n## 1  31500.0  0.12        3780.0\n## 2  39200.0  0.22        8624.0\n## 3  89075.0  0.24       21378.0\n## 4  29950.0  0.32        9584.0\n## 5     -0.0  0.35          -0.0\n## 6     -0.0  0.37          -0.0\n## np.float64(44393.5)\n```\n:::\n\n\n\n1. `brackets` defines the cutoffs for the different hierarchical tax rates, including the `[539900, Inf)` implicit bracket\n2. `x - brackets` calculates the amount of income taxed at or above each rate\n3. `pmax(0, x-brackets)` does not allow the values to go below 0, so that we're not paying negative taxes (though that would be nice, and some tax credits actually work that way)\n4. `diff(...)` subtracts value 1 from value 2, value 2 from value 3, and so on, shortening the vector by 1. This produces negative values in this case, so we have to multiply by -1 to get them back to positive values (we could also reverse the vector, diff, and then reverse again, e.g. `sum(rev(diff(pmax(0, rev(x-brackets)))) * rates)`).\n5. Then, we can multiply our values by their corresponding rates (`-diff(pmax(0, x-brackets))*rates`). \n6. Finally, we add up the values (`sum`) in the vector to get the total tax burden for someone making \\$200,000 per year. \n\n\n:::\n\nThis code uses slightly more memory by storing intermediate results, but it is much more readable -- you can clearly associate the steps to each line of code. \nWhen the tax code changes, it will also be easier to change -- instead of having to change the values of every tax bracket level in the conditional statement, we have to change the vector one time, and everything else will update accordingly. \n\n:::\n\nIt is always a trade-off to decide between a balance of computational time, computational resource requirements, programmer time (both to program and to maintain the code), and readability. \nThe vectorized calculation is less readable, but more computationally efficient. We can make it slightly more readable by increasing storage requirements and using intermediate variables that are well named to make the calculation process more comprehensible. \n\n::::\n\n## Loops\n\n<!-- https://www.py4e.com/html3/05-iterations -->\n\nOften, we write programs which update a variable in a way that the new value of the variable depends on the old value:\n\n    x = x + 1\n\nThis means that we add one to the current value of `x`.\n\nBefore we write a statement like this, we have to **initialize** the value of `x` because otherwise, we don't know what value to add one to.\n\n    x = 0\n    x = x + 1\n\nWe sometimes use the word **increment** to talk about adding one to the value of `x`; **decrement** means subtracting one from the value of `x`.\n\nA particularly powerful tool for making these types of repetitive changes in programming is the **loop**, which executes statements a certain number of times. \nLoops can be written in several different ways, but all loops allow for executing a block of code a variable number of times.\n\n### While Loops\n\nIn the previous section, we discussed conditional statements, where a block of code is only executed *if* a logical statement is true.\nThe simplest type of loop is the **while** loop, which executes a block of code until a statement is no longer true.\n\n::: example\n#### Example: While Loops {-}\n\n::: panel-tabset\n##### Flow Map\n\n![Flow map showing while-loop pseudocode (while x \\<= N) { \\# code that changes x in some way} and the program flow map expansion where we check if x \\> N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then change x and start over.](../images/gen-prog/while-loop-flow.png)\n\n##### R {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\n\nwhile (x < 10) { \n  # Everything in here is executed \n  # during each iteration of the loop\n  print(x)\n  x <- x + 1\n}\n## [1] 0\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n## [1] 8\n## [1] 9\n```\n:::\n\n\n\n\n##### Python {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 0\n\nwhile x < 10:\n  print(x)\n  x = x + 1\n## 0\n## 1\n## 2\n## 3\n## 4\n## 5\n## 6\n## 7\n## 8\n## 9\n```\n:::\n\n\n\n:::\n:::\n\n::: diy\n#### Try it Out - While Loops\n\n::: panel-tabset\n##### Problem {.unnumbered}\n\nWrite a while loop that verifies that $$\\lim_{N \\rightarrow \\infty} \\prod_{k=1}^N \\left(1 + \\frac{1}{k^2}\\right) = \\frac{e^\\pi - e^{-\\pi}}{2\\pi}.$$\n\nTerminate your loop when you get within 0.0001 of $\\frac{e^\\pi - e^{-\\pi}}{2\\pi}$. At what value of $k$ is this point reached?\n\n##### Math Notation {.unnumbered}\n\nBreaking down math notation for code:\n\n-   If you are unfamiliar with the notation $\\prod_{k=1}^N f(k)$, this is the product of $f(k)$ for $k = 1, 2, ..., N$, $$f(1)\\cdot f(2)\\cdot ... \\cdot f(N)$$\n\n-   To evaluate a limit, we just keep increasing $N$ until we get arbitrarily close to the right hand side of the equation.\n\nIn this problem, we can just keep increasing $k$ and keep track of the cumulative product. So we define `k=1`, `prod = 1`, and `ans` before the loop starts. Then, we loop over `k`, multiplying `prod` by $(1 + 1/k^2)$ and then incrementing $k$ by one each time. At each iteration, we test whether `prod` is close enough to `ans` to stop the loop.\n\n##### R Solution {.unnumbered}\n\nIn R, you will use `pi` and `exp()` - these are available by default without any additional libraries or packages.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 1\nprod <- 1\nans <- (exp(pi) - exp(-pi))/(2*pi)\ndelta <- 0.0001\n\nwhile (abs(prod - ans) >= 0.0001) {\n  prod <- prod * (1 + 1/k^2)\n  k <- k + 1\n}\n\nk\n## [1] 36761\nprod\n## [1] 3.675978\nans\n## [1] 3.676078\n```\n:::\n\n\n\n\n##### Python solution {.unnumbered}\n\nNote that in python, you will have to import the math library to get the values of pi and the `exp` function. You can refer to these as `math.pi` and `math.exp()` respectively.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport math\n\nk = 1\nprod = 1\nans = (math.exp(math.pi) - math.exp(-math.pi))/(2*math.pi)\ndelta = 0.0001\n\nwhile abs(prod - ans) >= 0.0001:\n  prod = prod * (1 + k**-2)\n  k = k + 1\n  if k > 500000:\n    break\n\n\nprint(\"At \", k, \" iterations, the product is \", prod, \"compared to the limit \", ans,\".\")\n## At  36761  iterations, the product is  3.675977910975878 compared to the limit  3.676077910374978 .\n```\n:::\n\n\n\n:::\n:::\n\n::: callout-warning\n#### Warning: Avoid Infinite Loops {-}\n\nIt is very easy to create an **infinite** loop when you are working with while loops. \nInfinite loops never exit, because the condition is always true. \nIf in the while loop example we decrement x instead of incrementing x, the loop will run forever.\n\nYou want to try very hard to avoid ever creating an infinite loop - it can cause your session to crash.\n\nOne common way to avoid infinite loops is to create a second variable that just counts how many times the loop has run. \nIf that variable gets over a certain threshold, you exit the loop.\n\n::: panel-tabset\n##### R {.unnumbered}\n\nThis while loop runs until either x \\< 10 or n \\> 50 - so it will run an indeterminate number of times and depends on the random values added to x. Since this process (a 'random walk') could theoretically continue forever, we add the n\\>30 check to the loop so that we don't tie up the computer for eternity.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nn <- 0 # count the number of times the loop runs\n\nwhile (x < 10) { \n  print(x)\n  x <- x + rnorm(1) # add a random normal (0, 1) draw each time\n  n <- n + 1\n  if (n > 30) \n    break # this stops the loop if n > 30\n}\n## [1] 0\n## [1] -0.6999157\n## [1] -1.488577\n## [1] -3.416473\n## [1] -3.551984\n## [1] -4.403012\n## [1] -3.638665\n## [1] -5.867218\n## [1] -5.493864\n## [1] -4.73579\n## [1] -6.201982\n## [1] -4.831426\n## [1] -6.013207\n## [1] -6.357643\n## [1] -5.404441\n## [1] -5.857407\n## [1] -6.506772\n## [1] -6.397666\n## [1] -5.519748\n## [1] -7.008371\n## [1] -7.187883\n## [1] -7.633027\n## [1] -7.703524\n## [1] -7.734773\n## [1] -7.729125\n## [1] -6.862941\n## [1] -6.840562\n## [1] -6.381707\n## [1] -6.060932\n## [1] -5.638446\n## [1] -4.375715\n```\n:::\n\n\n\n\n##### Python {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np; # for the random normal draw\n\nx = 0\nn = 0 # count the number of times the loop runs\n\nwhile x < 10:\n  print(x)\n  x = x + np.random.normal(0, 1, 1) # add a random normal (0, 1) draw each time\n  n = n + 1\n  if n > 50:\n    break # this stops the loop if n > 50\n## 0\n## [0.26347533]\n## [1.89365279]\n## [2.20355313]\n## [3.28545654]\n## [4.89117171]\n## [5.50485549]\n## [5.73126195]\n## [2.84108075]\n## [3.41491495]\n## [2.82287873]\n## [1.1817676]\n## [0.82886643]\n## [1.13379805]\n## [1.41570014]\n## [1.03726872]\n## [0.48418744]\n## [0.99300931]\n## [0.99367004]\n## [2.24995568]\n## [1.16782232]\n## [0.13320904]\n## [-0.07952444]\n## [0.15374879]\n## [0.01431605]\n## [0.04275899]\n## [0.76944886]\n## [0.554636]\n## [1.03214126]\n## [1.02176661]\n## [2.07486238]\n## [2.39914868]\n## [0.45870138]\n## [1.47565132]\n## [1.42003753]\n## [1.41940179]\n## [2.04938844]\n## [4.74342591]\n## [3.16382021]\n## [2.00783176]\n## [2.03214799]\n## [2.15530727]\n## [2.91544739]\n## [1.53786484]\n## [2.12686281]\n## [2.73375327]\n## [3.47318604]\n## [4.34221329]\n## [4.34083016]\n## [5.61808865]\n## [5.95977016]\n```\n:::\n\n\n\n:::\n\nIn both of the examples above, there are more efficient ways to write a random walk, but we will get to that later. \nThe important thing here is that we want to make sure that our loops don't run for all eternity.\n\n:::\n\n### For Loops\n\nAnother common type of loop is a **for** loop. \nIn a for loop, we run the block of code, iterating through a series of values (commonly, one to N, but not always). \nGenerally speaking, for loops are known as **definite** loops because the code inside a for loop is executed a specific number of times. \nWhile loops are known as **indefinite** loops because the code within a while loop is evaluated until the condition is falsified, which is not always a known number of times.\n\n![A visual demonstration of for loops iterating through a vector of monsters to dress them up for a parade. Image by [Allison Horst](https://twitter.com/allison_horst/status/1636395184106917889?s=20).](../images/tools/monster-parade.jpeg){fig-alt=\"Illustrated for loop where the input vector is a parade of monsters, including monsters that are circles, triangles, and squares. The for loop they enter has an if-else statement: if the monster is a triangle, it gets sunglasses. Otherwise, it gets a hat. The output is the parade of monsters where the same input parade of monsters shows up, now wearing either sunglasses (if triangular) or a hat (if any other shape).\"}\n\n::: demo\n#### Demo - For Loop Syntax {-}\n::: panel-tabset\n##### Flow Map {.unnumbered}\n\n![Flow map showing for-loop pseudocode (for j in 1 to N) { \\# code} and the program flow map expansion where j starts at 1 and we check if j \\> N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then increment j and start over.](../images/gen-prog/for-loop-flow.png)\n\n##### R {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5 ) {\n  print(i)\n}\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n```\n:::\n\n\n\n\n##### Python {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(5):\n  print(i)\n## 0\n## 1\n## 2\n## 3\n## 4\n```\n:::\n\n\n\n\nBy default `range`(5) goes from 0 to 5, the upper bound. When `i = 5` the loop exits. This is because `range(5)` creates a vector `[0, 1, 2, 3, 4]`.\n:::\n:::\n\nFor loops are often run from 1 to N (or 0 to N-1 in python) but in essence, a for loop is very commonly used to do a task for every value of a vector.\n\n::: example\n#### Example: For Loops\n::: panel-tabset\n##### R {.unnumbered}\n\nIn R, there is a built-in variable called `month.name`. Type `month.name` into your R console to see what it looks like. \nIf we want to iterate along the values of month.name, we can:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in month.name)\n  print(i)\n## [1] \"January\"\n## [1] \"February\"\n## [1] \"March\"\n## [1] \"April\"\n## [1] \"May\"\n## [1] \"June\"\n## [1] \"July\"\n## [1] \"August\"\n## [1] \"September\"\n## [1] \"October\"\n## [1] \"November\"\n## [1] \"December\"\n```\n:::\n\n\n\n\nWe can even pick out the first 3 letters of each month name and store them into a vector called `abbr3`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nabbr3 <- rep(\"\", length(month.name)) # <1>\n\nfor (i in 1:length(month.name))           # <2>\n  abbr3[i] <- substr(month.name[i], 1, 3) # <2>\n\ndata.frame(full_name = month.name, abbrev = abbr3) # <3>\n##    full_name abbrev\n## 1    January    Jan\n## 2   February    Feb\n## 3      March    Mar\n## 4      April    Apr\n## 5        May    May\n## 6       June    Jun\n## 7       July    Jul\n## 8     August    Aug\n## 9  September    Sep\n## 10   October    Oct\n## 11  November    Nov\n## 12  December    Dec\n```\n:::\n\n\n\n1. Create new vector of the correct length\n2. We have to iterate along the index (1 to length) instead of the name in this case because we want to store the result in a corresponding row of a new vector\n3. We can combine the two vectors into a data frame so that each row corresponds to a month and there are two columns: full month name, and abbreviation\n\n##### Python {.unnumbered}\n\nIn python, we have to define our vector or list to start out with, but that's easy enough:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport calendar\nmonth_name = list(calendar.month_name)[1:13] # <1>\n\nfor i in month_name: # <2>\n  print(i)           # <2>\n## January\n## February\n## March\n## April\n## May\n## June\n## July\n## August\n## September\n## October\n## November\n## December\n```\n:::\n\n\n\n1. Create a list with month names. For some reason, by default there's a \"\" as the first entry, so we'll get rid of that\n2. Iterate along the vector, printing out each element\n\n\nWe can even pick out the first 3 letters of each month name and store them into a vector called `abbr3`.\n\nPython handles lists best when you use [pythonic](https://stackoverflow.com/questions/522563/accessing-the-index-in-for-loops) expressions. \nThe linked post has an excellent explanation of why enumerate works best here.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nabbr3 = [\"\"] * len(month_name) # <1>\n\n\nfor i, val in enumerate(month_name): # <2> \n  abbr3[i] = val[0:3:] # <3>\n  \nabbr3\n## ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n```\n:::\n\n\n\n1. Create new vector of the correct length\n2. We have to iterate along the index because we want to store the result in a corresponding row of a new vector.  Python allows us to iterate along both the index `i` and the value `val` at the same time, which is convenient.\n3. Strings have indexes by character, so this gets  characters 0, 1, and 2.\n\n:::\n:::\n\nThere are additional types of iterators and control statements for iterators available in some languages, such as the `doWhile` loop and recursion. \nIf you're curious, expand the section below, but you can always write a `doWhile` loop as a while loop and can usually restate a recursion as a loop, so these constructs are largely for convenience. \n\n::: {.advanced  collapse=true}\n### do-while Loops\n\nThe do-while loop runs the code first and then evaluates the logical condition to determine whether the loop will be run again.\n\n\n::: demo\n##### Demo: do-while loops {-}\n\n::: panel-tabset\n###### R {-}\n\nIn R, do-while loops are most naturally implemented using a very primitive type of iteration: a `repeat` statement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat {\n  # statements go here\n  if (condition)\n    break # this exits the repeat statement\n}\n```\n:::\n\n\n\n\n###### Python {-}\n\nIn python, do-while loops are most naturally implemented using a while loop with condition TRUE:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nwhile TRUE:\n  # statements go here\n  if condition:\n    break\n\n```\n:::\n\n\n\n\n:::\n:::\n\n### Recursion\n\nAn additional means of running code an indeterminate number of times is the use of **recursion**, which we cannot cover until we learn about functions. \nI have added an additional section, @sec-recursion, to cover this topic, but it is not essential to being able to complete most basic data programming tasks.\nRecursion is useful when working with structures such as trees (including phylogenetic trees) and nested lists.\n\n### Controlling Loops with Break, Next, Continue\n\nWhile I do not often use break, next, and continue statements, they do exist in both languages and can be useful for controlling the flow of program execution. \nI have moved the section on this to @sec-controlling-loops for the sake of brevity and to reduce the amount of new material those without programming experience are being exposed to in this section.\n\n:::\n\n## References  {#sec-control-struct-refs}\n\n",
    "supporting": [
      "04-control-struct_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}