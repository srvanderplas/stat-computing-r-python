{
  "hash": "4fc318bd5f8c9ee6e61d438cfbb028be",
  "result": {
    "engine": "knitr",
    "markdown": "# Writing Functions {#sec-functions}\n\nA **function** is a set of actions that we group together and name. \nThroughout this course, you've used a bunch of different functions in R and python that are built into the language or added through packages: `mean`, `ggplot`, `length`, `print`. \nIn this chapter, we'll be writing our own functions.\n\n## Objectives {-}\n\n- Identify the parts of a function from provided source code\n- Predict what the function will return when provided with input values and source code\n- Given a task, lay out the steps necessary to complete the task in pseudocode\n- Write a function which uses necessary input values to complete a task\n\n## When to write a function? \n\nIf you've written the same code (with a few minor changes, like variable names) more than twice, you should probably write a function instead. There are a few benefits to this rule:\n\n1. Your code stays neater (and shorter), so it is easier to read, understand, and maintain.\n\n2. If you need to fix the code because of errors, you only have to do it in one place.\n\n3. You can re-use code in other files by keeping functions you need regularly in a file (or if you're really awesome, in your own package!)\n\n4. If you name your functions well, your code becomes easier to understand thanks to grouping a set of actions under a descriptive function name.\n\n\n::: {.callout-note}\n### Learn more about functions\n\nThere is some extensive material on this subject in R for Data Science [@r4ds] on [functions](https://r4ds.had.co.nz/functions.html). If you want to really understand how functions work in R, that is a good place to go.\n\n:::\n    \n\n\n:::{.callout-caution}\n### Example: Turning Code into Functions\n\nThis example is modified from R for Data Science [@advr, Chapter 19]. \n\nWhat does this code do? Does it work as intended?\n\n::: {.panel-tabset}\n\n### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble::tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\ndf$b <- (df$b - min(df$b, na.rm = TRUE)) / \n  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))\ndf$c <- (df$c - min(df$c, na.rm = TRUE)) / \n  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))\ndf$d <- (df$d - min(df$d, na.rm = TRUE)) / \n  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))\n```\n:::\n\n\n\n\n### Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({\n  'a': np.random.randn(10), \n  'b': np.random.randn(10), \n  'c': np.random.randn(10), \n  'd': np.random.randn(10)})\n\ndf.a = (df.a - min(df.a))/(max(df.a) - min(df.a))\ndf.b = (df.b - min(df.b))/(max(df.b) - min(df.a))\ndf.c = (df.c - min(df.c))/(max(df.c) - min(df.c))\ndf.d = (df.d - min(df.d))/(max(df.d) - min(df.d))\n```\n:::\n\n\n\n\n:::\n\nThe code rescales a set of variables to have a range from 0 to 1. But, because of the copy-pasting, the code's author made a mistake and forgot to change an `a` to `b`. \n\nWriting a function to rescale a variable would prevent this type of copy-paste error.\n\nTo write a function, we first analyze the code to determine how many inputs it has:\n\n::: {.panel-tabset}\n\n### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\n```\n:::\n\n\n\n\nThis code has only one input: `df$a`. \n\n### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\ndf.a = (df.a - min(df.a))/(max(df.a) - min(df.a))\n```\n:::\n\n\n\n\n\nThis code has only one input: `df.a` \n\n:::\n\n\nTo convert the code into a function, we start by rewriting it using general names:\n\n::: {.panel-tabset}\n\n### R {-}\n\nIn this case, it might help to replace `df$a` with `x`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- df$a \n\n(x - min(x, na.rm = TRUE)) / \n  (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n##  [1] 0.581391290 0.007536146 0.626946965 0.208882202 0.725541365 1.000000000\n##  [7] 0.715149210 0.632900935 0.361504713 0.000000000\n```\n:::\n\n\n\n\n### Python {-}\n\nIn this case, it might help to replace `df.a` with `x`.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = df.a\n\n(x - min(x))/(max(x) - min(x))\n## 0    0.727906\n## 1    0.669877\n## 2    0.413203\n## 3    0.113864\n## 4    1.000000\n## 5    0.277004\n## 6    0.860675\n## 7    0.258617\n## 8    0.000000\n## 9    0.398647\n## Name: a, dtype: float64\n```\n:::\n\n\n\n\n:::\n\nThen, we make it a bit easier to read, removing duplicate computations if possible (for instance, computing `min` two times).\n\n\n::: {.panel-tabset}\n\n### R {-}\n\nIn R, we can use the `range` function, which computes the maximum and minimum at the same time and returns the result as `c(min, max)`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrng <- range(x, na.rm = T)\n\n(x - rng[1])/(rng[2] - rng[1])\n##  [1] 0.581391290 0.007536146 0.626946965 0.208882202 0.725541365 1.000000000\n##  [7] 0.715149210 0.632900935 0.361504713 0.000000000\n```\n:::\n\n\n\n\n### Python {-}\n\nIn python, `range` is the equivalent of `seq()` in R, so we are better off just using `min` and `max`. \n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = df.a\n\n\nxmin, xmax = [x.min(), x.max()]\n(x - xmin)/(xmax - xmin)\n## 0    0.727906\n## 1    0.669877\n## 2    0.413203\n## 3    0.113864\n## 4    1.000000\n## 5    0.277004\n## 6    0.860675\n## 7    0.258617\n## 8    0.000000\n## 9    0.398647\n## Name: a, dtype: float64\n```\n:::\n\n\n\n\n:::\n\nFinally, we turn this code into a function:\n\n::: {.panel-tabset}\n\n### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrescale01 <- function(x) {\n  rng <- range(x, na.rm = T)\n  (x - rng[1])/(rng[2] - rng[1])\n}\n\nrescale01(df$a)\n##  [1] 0.581391290 0.007536146 0.626946965 0.208882202 0.725541365 1.000000000\n##  [7] 0.715149210 0.632900935 0.361504713 0.000000000\n```\n:::\n\n\n\n\n- The name of the function, `rescale01`, describes what the function does - it rescales the data to between 0 and 1. \n- The function takes one **argument**, named `x`; any references to this value within the function will use `x` as the name. \nThis allows us to use the function on `df$a`, `df$b`, `df$c`, and so on, with `x` as a placeholder name for the data we're working on at the moment.\n- The code that actually does what your function is supposed to do goes in the **body** of the function, between `{` and `}` (this is true in R, in python, there are different conventions, but the same principle applies)\n- The function **returns** the last value computed: in this case, `(x - rng[1])/(rng[2]-rng[1])`. You can make this explicit by adding a `return()` statement around that calculation.\n\n### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef rescale01(x):\n  xmin, xmax = [x.min(), x.max()]\n  return (x - xmin)/(xmax - xmin)\n\nrescale01(df.a)\n## 0    0.727906\n## 1    0.669877\n## 2    0.413203\n## 3    0.113864\n## 4    1.000000\n## 5    0.277004\n## 6    0.860675\n## 7    0.258617\n## 8    0.000000\n## 9    0.398647\n## Name: a, dtype: float64\n```\n:::\n\n\n\n\n- The name of the function, `rescale01`, describes what the function does - it rescales the data to between 0 and 1. \n- The function takes one **argument**, named `x`; any references to this value within the function will use `x` as the name. This allows us to use the function on `df.a`, `df.b`, `df.c`, and so on, with `x` as a placeholder name for the data we're working on at the moment.\n- The code that actually does what your function is supposed to do goes in the **body** of the function, indented relative to the line with `def: function_name():`. \nAt the end of the function, you should have a blank line with no spaces or tabs.\n\n- The function **returns** the value it is told to `return`: in this case, `(x - xmin)/(xmax - xmin)`. \nIn Python, you must `return` a value if you want the function to perform a computation. ^[This is not strictly true, you can of course use pass-by-reference, but we will not be covering that in this class as we are strictly dealing with the bare minimum of learning how to write a function here.]\n\n:::\n\nThe process for creating a function is important: first, you figure out how to do the thing you want to do. \nThen, you simplify the code as much as possible. Only at the end of that process do you create an actual function.\n\n:::\n\n\n## Syntax\n\n![R and python syntax for defining functions. Portions of the command that indicate the function name, function scope, and return statement are highlighted in each block.](../images/gen-prog/Annotating_function_syntax.png)\n\nIn R, functions are defined as other variables, using `<-`, but we specify the arguments a function takes by using the `function()` statement. \nThe contents of the function are contained within `{` and `}`. \nIf the function returns a value, a `return()` statement can be used; alternately, if there is no return statement, the last computation in the function will be returned.\n\nIn python, functions are defined using the `def` command, with the function name, parentheses, and the function arguments to follow. \nThe first line of the function definition ends with a `:`, and all subsequent lines of the function are indented (this is how python knows where the end of the function is). \nA python function return statement is `return <value>`, with no parentheses needed.\n\nNote that in python, the `return` statement is not optional. \nIt is not uncommon to have python functions that don't return anything; in R, this is a bit less common, for reasons we won't get into here.\n\n## Arguments and Parameters\n\nAn **argument** is the name for the object you pass into a function.\n\nA **parameter** is the name for the object once it is inside the function (or the name of the thing as defined in the function).\n\n::: {.callout-caution}\n### Example: Parts of a Function\n\nLet's examine the difference between arguments and parameters by writing a function that takes a dog's name and returns \"<name> is a good pup!\".\n\n:::: {.panel-tabset}\n\n### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndog <- \"Eddie\"\n\ngoodpup <- function(name) {\n  paste(name, \"is a good pup!\")\n}\n\ngoodpup(dog)\n## [1] \"Eddie is a good pup!\"\n```\n:::\n\n\n\n\n\n### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndog = \"Eddie\"\n\ndef goodpup(name):\n  return name + \" is a good pup!\"\n\ngoodpup(dog)\n## 'Eddie is a good pup!'\n```\n:::\n\n\n\n\n\n::::\n\nIn this example function, when we call `goodpup(dog)`, `dog` is the argument. \n`name` is the parameter. \n\nWhat is happening inside the computer's memory as `goodpup` runs?\n\n![A sketch of the execution of the program `goodpup`, showing that `name` is only defined within the local environment that is created while `goodpup` is running. We can never access `name` in our global environment.](../images/gen-prog/function_argument_parameters.png)\n\n:::\n\nThis is why the distinction between **arguments** and **parameters** matters. \nParameters are only accessible while inside of the function - and in that local environment, we need to call the object by the parameter name, not the name we use outside the function (the argument name). \n\nWe can even call a function with an argument that isn't defined outside of the function call: `goodpup(\"Tesla\")` produces \"Tesla is a good pup!\". \nHere, I do not have a variable storing the string \"Tesla\", but I can make the function run anyways. \nSo \"Tesla\" here is an argument to `goodpup` but it is not a variable in my environment.\n\nThis is a confusing set of concepts and it's ok if you only just sort of get what I'm trying to explain here. \nHopefully it will become more clear as you write more code.\n\n::: {.callout-tip}\n### Try it out: Function Parts {-}\n\nFor each of the following blocks of code, identify the function name, function arguments, parameter names, and return statements. \nWhen the function is called, see if you can predict what the output will be. \nAlso determine whether the function output is stored in memory or just printed to the command line.\n\n::: {.panel-tabset}\n\n#### Function 1 {-}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef hello_world():\n  print(\"Hello World\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nhello_world()\n```\n:::\n\n\n\n\n#### Answer {-}\n\n- Function name: `hello_world`\n- Function parameters: none\n- Function arguments: none\n- Function output: \n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nhello_world()\n## Hello World\n```\n:::\n\n\n\n\n- Function output is not stored in memory and is printed to the command line.\n\n:::\n\n\n::: {.panel-tabset}\n\n#### Function 2 {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mean <- function(x) {\n  censor_x <- sample(x, size = length(x) - 2, replace = F)\n  mean(censor_x)\n}\n\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(3420523)\nx = my_mean(1:10)\nx\n```\n:::\n\n\n\n\n#### Answer {-}\n\n- Function name: `my_mean`\n- Function parameters: x\n- Function arguments: 1:10\n- Function output: (varies each time the function is run unless you set the seed)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(3420523)\nx = my_mean(1:10)\nx\n## [1] 6\n```\n:::\n\n\n\n\n- Function output is saved to memory (`x`) and printed to the command line\n\n:::\n\n:::\n\n### Named Arguments and Parameter Order\n\nIn the examples above, you didn't have to worry about what order parameters were passed into the function, because there were 0 and 1 parameters, respectively. \nBut what happens when we have a function with multiple parameters?\n\n::: {.panel-tabset}\n\n#### R  {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ndivide <- function(x, y) {\n  x / y\n}\n\n```\n:::\n\n\n\n\n#### Python {-}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\ndef divide(x, y):\n  return x / y\n```\n:::\n\n\n\n\n:::\n\nIn this function, the order of the parameters matters! `divide(3, 6)` does not produce the same result as `divide(6, 3)`. \nAs you might imagine, this can quickly get confusing as the number of parameters in the function increases.\n\nIn this case, it can be simpler to use the parameter names when you pass in arguments.\n\n::: {.panel-tabset}\n\n#### R  {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndivide(3, 6)\n## [1] 0.5\n\ndivide(x = 3, y = 6)\n## [1] 0.5\n\ndivide(y = 6, x = 3)\n## [1] 0.5\n\ndivide(6, 3)\n## [1] 2\n\ndivide(x = 6, y = 3)\n## [1] 2\n\ndivide(y = 3, x = 6)\n## [1] 2\n```\n:::\n\n\n\n\n#### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndivide(3, 6)\n## 0.5\n\ndivide(x = 3, y = 6)\n## 0.5\n\ndivide(y = 6, x = 3)\n## 0.5\n\ndivide(6, 3)\n## 2.0\n\ndivide(x = 6, y = 3)\n## 2.0\n\ndivide(y = 3, x = 6)\n## 2.0\n```\n:::\n\n\n\n\n:::\n\nAs you can see, the order of the arguments doesn't much matter, as long as you use named arguments, but if you don't name your arguments, the order very much matters.\n\n### Input Validation\n\nWhen you write a function, you often assume that your parameters will be of a certain type. \nBut you can't guarantee that the person using your function knows that they need a certain type of input. \nIn these cases, it's best to **validate** your function input.\n\n::: {.callout-caution}\n\n#### Input Validation Example {-}\n\n::: panel-tabset\n\n##### R {-}\n\nIn R, you can use `stopifnot()` to check for certain essential conditions. \nIf you want to provide a more illuminating error message, you can check your conditions using `if()` and then use `stop(\"better error message\")` in the body of the if statement. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y) {\n  x + y\n}\n\nadd(\"tmp\", 3)\n## Error in x + y: non-numeric argument to binary operator\n\nadd <- function(x, y) {\n  stopifnot(is.numeric(x))\n  stopifnot(is.numeric(y))\n  x + y\n}\n\nadd(\"tmp\", 3)\n## Error in add(\"tmp\", 3): is.numeric(x) is not TRUE\nadd(3, 4)\n## [1] 7\n```\n:::\n\n\n\n\n##### Python {-}\n\nIn Python, the easiest way to handle errors is to use a try statement, which operates rather like an if statement: if the statement executes, then we're good to go; if not, we can use `except` to handle different types of errors. \nThe `else` clause is there to handle anything that needs to happen if the statement in the `try` clause executes without any errors.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef add(x, y):\n  x + y\n\nadd(\"tmp\", 3)\n## TypeError: can only concatenate str (not \"int\") to str\n\ndef add(x, y):\n  try:\n    return x + y\n  except TypeError:\n    print(\"x and y must be add-able\")\n  else:\n    # We should never get here, because the try clause has a return statement\n    print(\"Else clause?\")\n  return\n\nadd(\"tmp\", 3)\n## x and y must be add-able\nadd(3, 4)\n## 7\n```\n:::\n\n\n\n\nYou can read more about error handling in Python [here](https://docs.python.org/3/tutorial/errors.html)\n\n:::\n\n:::\n\nInput validation is one aspect of **defensive programming** - programming in such a way that you try to ensure that your programs don't error out due to unexpected bugs by anticipating ways your programs might be misunderstood or misused [@DefensiveProgramming2022].\n\n\n## Scope\n\nWhen talking about functions, for the first time we start to confront a critical concept in programming, which is scope. **Scope** is the part of the program where the name you've given a variable is valid - that is, where you can use a variable.\n\n> A variable is only available from inside the region it is created.\n\nWhat do I mean by the part of a program? The **lexical scope** is the portion of the code (the set of lines of code) where the name is valid.\n\nThe concept of scope is best demonstrated through a series of examples, so in the rest of this section, I'll show you some examples of how scope works and the concepts that help you figure out what \"scope\" actually means in practice.\n\n\n### Name Masking\n\nScope is most clearly demonstrated when we use the same variable name inside and outside a function. Note that this is 1) bad programming practice, and 2) fairly easily avoided if you can make your names even slightly more creative than `a`, `b`, and so on. But, for the purposes of demonstration, I hope you'll forgive my lack of creativity in this area so that you can see how name masking works.\n\n::: {.callout-caution}\n#### Guess and Check {-}\nWhat does this function return, 10 or 20? \n\n::: panel-tabset\n\n##### Pseudocode {-}\n\n```\na = 10\n\nmyfun = function() {\n  a = 20\n  return a\n}\n\nmyfun()\n```\n\n##### Sketch {-}\n\n![A sketch of the global environment as well as the environment within `myfun()`. Because `a=20` inside `myfun()`, when we call `myfun()`, we get the value of `a` within that environment, instead of within the global environment.](../images/gen-prog/function-scope.png)\n\n#### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 10\n\nmyfun <- function() {\n  a <- 20\n  a\n}\n\nmyfun()\n## [1] 20\n```\n:::\n\n\n\n\n##### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\na = 10\n\ndef myfun():\n  a = 20\n  return a\n\nmyfun()\n## 20\n```\n:::\n\n\n\n\n:::\n\n:::\n\nThe lexical scope of the function is the area that is between the braces (in R) or the indented region (in python). \nOutside the function, `a` has the value of 10, but inside the function, `a` has the value of 20.\nSo when we call `myfun()`, we get 20, because the scope of `myfun` is the **local context** where `a` is evaluated, and the value of `a` in that environment dominates.\n\nThis is an example of **name masking**, where names defined inside of a function mask names defined outside of a function.\n\n\n### Environments and Scope\n\nAnother principle of scoping is that if you call a function and then call the same function again, the function's environment is re-created each time. \nEach function call is unrelated to the next function call when the function is defined using local variables.\n\n::: {.callout-caution}\n#### Guess and Check {-}\n\nWhat does this output?\n\n::: panel-tabset\n\n##### Pseudocode {-}\n\n```\nmyfun = function() {\n  if a is not defined\n    a = 1\n  else\n    a = a + 1\n}\n\nmyfun()\nmyfun()\n\n```\n\n\n##### Sketch {-}\n\n![When we define myfun, we create a template for an environment with variables and code to excecute. Each time `myfun()` is called, that template is used to create a new environment. This prevents successive calls to `myfun()` from affecting each other -- which means `a = 1` every time.](../images/gen-prog/function-scope-environment.png)\n\n\n##### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfun <- function() {\n  if (!exists(\"aa\")) {\n    aa <- 1\n  } else {\n    aa <- aa + 1\n  }\n  return(aa)\n}\n\nmyfun()\n## [1] 1\nmyfun()\n## [1] 1\n```\n:::\n\n\n\n\n##### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef myfun():\n  try: aa\n  except NameError: aa = 1\n  else: aa = aa + 1\n  return aa\n\nmyfun()\n## 1\nmyfun()\n## 1\n```\n:::\n\n\n\n\nNote that the `try` command here is used to handle the case where a doesn't exist. \nIf there is a NameError (which will happen if `aa` is not defined) then we define `aa = 1`, if there is not a NameError, then `aa = aa + 1`. \n\nThis is necessary because [Python does not have a built-in way to test if a variable exists before it is used](https://www.oreilly.com/library/view/python-cookbook/0596001673/ch17s02.html) [@martelliPythonCookbook2002, Ch 17].\n\n:::\n\n:::\n\n### Dynamic Lookup\n\nScoping determines where to look for values -- when, however, is determined by the sequence of steps in the code. \nWhen a function is called, the **calling environment** (the global environment or set of environments at the time the function is called) determines what values are used. \n\nIf an object doesn't exist in the function's environment, the global environment will be searched next; if there is no object in the global environment, the program will error out. \nThis behavior, combined with changes in the calling environment over time, can mean that the output of a function can change based on objects outside of the function.\n\n::: {.callout-caution}\n#### Guess and Check {-}\n\nWhat will this code output?\n\n::: panel-tabset\n\n##### Pseudocode {-}\n\n```\nmyfun = function() x + 1\n\nx = 14\n\nmyfun()\n\nx = 20\n\nmyfun()\n\n```\n\n\n##### Sketch {-}\n\n![The state of the global environment at the time the function is called (that is, the state of the calling environment) can change the results of the function](../images/gen-prog/function-scope-calling-environment.png)\n\n\n##### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfun <- function() {\n  x + 1\n}\n\nx <- 14\n\nmyfun()\n## [1] 15\n\nx <- 20\n\nmyfun()\n## [1] 21\n```\n:::\n\n\n\n\n##### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\ndef myfun():\n  return x + 1\n\n\nx = 14\n\nmyfun()\n## 15\n\nx = 20\n\nmyfun()\n## 21\n```\n:::\n\n\n\n\n:::\n:::\n\n:::{.callout-tip}\n### Try It Out: Function Scope {-}\n\nWhat does the following function return? Make a prediction, then run the code yourself. \n[From @advr, Chapter 6]\n\n::: panel-tabset\n\n##### R code {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n```\n:::\n\n\n\n\n##### R solution {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n## [1] 202\n```\n:::\n\n\n\n\n##### Python code {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef f(x):\n  def f(x):\n    def f():\n      return x ** 2\n    return f() + 1\n  return f(x) * 2\n\nf(10)\n```\n:::\n\n\n\n\n##### Python solution {-}\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef f(x):\n  def f(x):\n    def f():\n      return x ** 2\n    return f() + 1\n  return f(x) * 2\n\nf(10)\n## 202\n```\n:::\n\n\n\n\n:::\n\n:::\n\n## References {#sec-functions-refs}\n",
    "supporting": [
      "05-functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}