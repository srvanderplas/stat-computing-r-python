{
  "hash": "b1fe8f33be297c653b443a60bd91b040",
  "result": {
    "markdown": "# Debugging {#sec-debugging}\n\nNow that you're writing functions, it's time to talk a bit about debugging techniques. \nThis is a lifelong topic - as you become a more advanced programmer, you will need to develop more advanced debugging skills as well (because you'll become more adept at screwing things up).\n\n## {{< fa bullseye >}} Objectives\n\n- Create reproducible examples of problems\n\n- Use built in debugging tools to trace errors\n\n- Use online resources to research errors\n\n\n![The faces of debugging (by Allison Horst)](../images/gen-prog/debugging.jpg){fig-alt=\"A cartoon of a fuzzy round monster face showing 10 different emotions experienced during the process of debugging code. The progression goes from (1) “I got this” - looking determined and optimistic; (2) “Huh. Really thought that was it.” - looking a bit baffled; (3) “...” - looking up at the ceiling in thought; (4) “Fine. Restarting.” - looking a bit annoyed; (5) “OH WTF.” Looking very frazzled and frustrated; (6) “Zombie meltdown.” - looking like a full meltdown; (7) (blank) - sleeping; (8) “A NEW HOPE!” - a happy looking monster with a lightbulb above; (9) “insert awesome theme song” - looking determined and typing away; (10) “I love coding” - arms raised in victory with a big smile, with confetti falling.\"}\n\n## Avoiding Errors: Defensive Programming\n\nOne of the best debugging strategies (that isn't a debugging strategy at all, really) is to code defensively [@DefensiveProgramming2022]. By that, I mean, code in a way that you will make debugging things easier later. \n\n- **Modularize your code**. Each function should do only one task, ideally in the least-complex way possible.\n\n- **Make your code readable**. If you can read the code easily, you'll be able to narrow down the location of the bug more quickly.\n\n- **Comment your code**. This makes it more likely that you will be able to locate the spot where the bug is likely to have occurred, and will remind you how things are calculated. Remember, comments aren't just for your collaborators or others who see the code. They're for future you.\n\n- **Don't duplicate code**. If you have the same code (or essentially the same code) in two or three different places, put that code in a function and call the function instead. This will save you trouble when updating the code in the future, but also makes narrowing down the source of the bug less complex.\n\n- **Reduce the number of dependencies** you have on outside software packages. Often bugs are introduced when a dependency is updated and the functionality changes slightly. The `tidyverse` [@tidyverse] is *notorious* for this.     \n\n::: callout-note\nIt's ok to write code using lots of dependencies, but as you transition from \"experimental\" code to \"production\" code (you're using the code without tinkering with it) you should work to reduce the dependencies, where possible. In addition, if you do need packages with lots of dependencies, try to make sure those packages are relatively popular, used by a lot of people, and currently maintained. (The tidyverse is a bit better from this perspective, because the constituent packages are some of the most installed R packages on CRAN.)\n:::\n    \nAnother way to handle dependency management is to use the `renv` package [@renv], which creates a local package library with the appropriate versions of your packages stored in the same directory as your project. `renv` was inspired by the python concept of virtual environments, and it does also work with python if you're using both R and python inside a project (e.g. this book uses `renv`). `renv` will at the very least help you minimize issues with code not working after unintentional package updates.\n\n- **Add safeguards against unexpected inputs**. Check to make sure inputs to the function are valid. Check to make sure intermediate results are reasonable (e.g. you don't compute the derivative of a function and come up with \"a\".)\n\n- **Don't reinvent the wheel**. If you have working, tested code for a task, use that! If someone else has working code that's used by the community, don't write your own unless you have a very good reason. The implementation of `lm` has been better tested than your homegrown linear regression.\n\n- Collect your often-reused code in packages that you can easily load and make available to \"future you\". The process of making a package often encourages you to document your code better than you would a script. A good resource for getting started making R packages is @wickhamPackagesOrganizeTest2015, and a similar python book is @beuzenPythonPackages2022.\n\n## Working through Errors\n\n### First steps\n\n#### Get into the right mindset\nYou can't debug something effectively if you're upset. You have to be in a puzzle-solving, detective mindset to actually solve a problem. If you're already stressed out, try to relieve that stress before you tackle the problem: take a shower, go for a walk, pet a puppy.\n\n\n![A debugging manifesto [@evansDebuggingManifestoHttps2022]](../images/gen-prog/b0rk-debugging-manifesto.jpeg){fig-alt=\"a debugging manifesto.\n1. inspect, dont squash. try to fix the bug (crossed out). understand what happened (yes, smiley faces and stars)\n2. check your assumptions. person (thinking): \\\"wait, how do I know thats true?\\\"\n3. being stuck is temporary. person (thinking): \\\"I will never figure this out!\\\" ... 2 minutes later.... person (thinking): \\\"well, I havent tried X...\\\"\n4. dont go it alone. person (speaking to other person): \\\"hey, have you seen this problem before?\\\"\n5. trust nobody and nothing. person (thinking): this library cant be buggy... OR CAN IT???\n6. there's always a reason. computer: \\\"computers are always logical, even when it doesnt feel that way\\\"\n7. build your toolkit. person (holding toolkit): \\\"wow, the CSS inspector makes debugging SO MUCH EASIER\\\"\n8. it can be an adventure. person (talking, with cute bug next to them): \\\"you wouldnt BELIEVE the weird bug I found\\\". by @b0rk @omarieclaire, more like this at https://wizardzines.com\"}\n\n\n\n#### Check your spelling\n\nI'll guess that 80% of my personal debugging comes down to spelling errors and misplaced punctuation. \n\n![Title: user.fist_name [@nasserUserFistName2020]](../images/gen-prog/nasser_junior-misspelled.jpeg){fig-alt=\"A programmer clutches a laptop and says 'I hate this job'... 'and I hate my life' (while pulling at its face). The programmer screams 'WHY IS THIS HAPPENING TO MEEEE'. In the final frame, a calm programmer resumes typing and says 'nevermind, misspelled a variable.'\"\nwidth=\"60%\"}\n\n### General Debugging Strategies\n\n::: column-margin\n> Debugging: Being the detective in a crime movie where you are also the murderer. - some t-shirt I saw once\n:::\n\nWhile defensive programming is a nice idea, if you're already at the point where you have an error you can't diagnose, then... it doesn't help that much. At that point, you'll need some general debugging strategies to work with. The overall process is well described in @advr; I've added some steps that are commonly overlooked and modified the context from the original package development to introductory programming. I've also integrated some lovely illustrations from [Julia Evans (\\@b0rk)](https://twitter.com/b0rk) to lighten the mood.\n\n0. Realize that you have a bug\n\n1. Read the error message\n\n![Debugging strategy: Reread the error message[@evansDebuggingStrategyReread2022]](../images/gen-prog/b0rk-reread_error_message.jpeg){fig-alt=\"Image description title: reread the error message. After I've read the error message, I sometimes run into one of these 2 problems: 1. misreading the message. person (thinking): ok, it says the error is in file X. spoiler: it actually said file Y. 2. disregarding what the message is saying. person (thinking): well, the message says X, but that's impossible... spoiler: it was possible. Rereading the message can feel pointless (I already read it!!) but it's fast and it can REALLY help.\"}\n\n2. **Google!** Seriously, just google the whole error message.    \nIn R you can automate this with the `errorist` and `searcher` packages. Python is so commonly used that you'll likely be able to find help for your issue if you are specific enough.\n\n::: column-margin\n![Debugging strategy: Shorten your feedback loop [@evansDebuggingStrategyShorten2022]](../images/gen-prog/b0rk-shorten_feedback_loop.jpeg){fig-alt=\"strategy: shorten your feedback loop. When I'm debugging, I: 1. come up with a question 2. run the buggy code to answer my question 3. repeat dozens of times. If step 2 is slow, everything takes FOREVER. Some ways to speed it up: * use a browser automation tool! * write a unit test! * write a tiny program!\"}\n:::\n\n3. **Make the error repeatable**: This makes it easier to figure out what the error is, faster to iterate, and easier to ask for help.\n    - Use binary search (remove 1/2 of the code, see if the error occurs, if not go to the other 1/2 of the code. Repeat until you've isolated the error.)\n    - Generate the error faster - use a minimal test dataset, if possible, so that you can ask for help easily and run code faster. This is worth the investment if you've been debugging the same error for a while. \n    ![Debugging strategy: Write a tiny program [@evansDebuggingStrategyWrite2022a]](../images/gen-prog/b0rk-tiny_program.jpeg){fig-alt=\"strategy: write a tiny program. Does your bug involve a library you don't understand? illustration: person (thought bubble): UGH, `requests` is NOT working how I expected it to! I like to convert my code using that library into a tiny standalone program which has the same bug: illustration: giant buggy program (squiggly mess) -> 20 lines of buggy code (simple) I find this makes it WAY EASIER to experiment and ask for help.\"}\n    \n    - Note which inputs *don't* generate the bug -- this negative \"data\" is helpful when asking for help.\n    \n    ![Debugging strategy: Change working code into broken code [@evansDebuggingStrategyChange2022]](../images/gen-prog/b0rk-break_code.jpeg){fig-alt=\"strategy: change working code into broken code . If I have a working version of the program, I like to: * go back to the working code * slowly start changing it to be more like my broken code * test if it's still working after every single tiny change. I like this because it puts me back on solid ground: with every change I make that DOESN'T cause the bug to come back, I know that wasn't the problem.\"}\n\n\n\n4. **Figure out where it is**. Debuggers may help with this, but you can also use the [scientific method](http://web.mit.edu/6.031/www/fa17/classes/13-debugging/#find_the_bug_using_the_scientific_method) to explore the code, or the tried-and-true method of using lots of `print()` statements.\n\n5. **Come up with one question**. If you're stuck, it can be helpful to break it down a bit and ask one tiny question about the bug.\n\n![Debugging strategy: Come up with one question [@evansDebuggingStrategyCome2022]](../images/gen-prog/b0rk-one_question.jpeg){fig-alt=\"debugging strategy: come up with one question. Debugging can feel huge and impossible. But all you have to do to make progress is: 1. find ONE QUESTION about the bug you don't know the answer to, and 2. figure out the answer to that question. illustration: person: I'm stuck! question they're asking: where is the code that's responsible for doing X? side note: ignore all these other questions for now! one at a time!\"}\n\n\n6. **Fix it and test it**. The goal with tests is to ensure that the same error doesn't pop back up in a future version of your code. Generate an example that will test for the error, and add it to your documentation. If you're developing a package, unit test suites offer a more formalized way to test errors and you can automate your testing so that every time your code is changed, tests are run and checked.\n\n::: column-margin\n![Debugging strategy: Write a unit test [@evansDebuggingStrategyWrite2022]](../images/gen-prog/b0rk-unit-test.jpeg){fig-alt=\"Image description\nstrategy: write a unit test. If your program already has tests, adding a failing test can be a great way to work on your bug! person (thinking): \\\"this function should return X, but it's returning Y\\\". * it forces you to pinpoint what exactly the bug is * it's easy to tell when you've fixed it (the test passes!) * you can keep the test to make sure the bug doesn't come back\"}\n:::\n\nThere are several other general strategies for debugging:\n\n- Retype (from scratch) your code    \nThis works well if it's a short function or a couple of lines of code, but it's less useful if you have a big script full of code to debug. However, it does sometimes fix really silly typos that are hard to spot, like having typed `<--` instead of `<-` in R and then wondering why your answers are negative. \n\n- Visualize your data as it moves through the program. This may be done using `print()` statements, or the debugger, or some other strategy depending on your application.\n\n- Tracing statements. Again, this is part of `print()` debugging, but these messages indicate progress - \"got into function x\", \"returning from function y\", and so on. \n\n- Rubber ducking. Have you ever tried to explain a problem you're having to someone else, only to have a moment of insight and \"oh, never mind\"? Rubber ducking outsources the problem to a nonjudgmental entity, such as a rubber duck^[Some people use cats, but I find that they don't meet the nonjudgmental criteria. Of course, they're equally judgmental whether your code works or not, so maybe that works if you're a cat person, which I am not. Dogs, in my experience, can work, but often will try to comfort you when they realize you're upset, which both helps and lessens your motivation to fix the problem. A rubber duck is the perfect dispassionate listener.]. You simply explain, in terms simple enough for your rubber duck to understand, exactly what your code does, line by line, until you've found the problem. [See @monteiroImproveHowYou2019a for a more thorough explanation]. \n\nDo not be surprised if, in the process of debugging, you encounter new bugs. \nThis is a problem that's well-known enough that it has its [own xkcd comic](https://xkcd.com/1739/). \nAt some point, getting up and going for a walk may help. \nRedesigning your code to be more modular and more organized is also a good idea. \n\n\n## Dividing Problems into Smaller Parts\n\n> “Divide each difficulty into as many parts as is feasible and necessary to resolve it.” -René Descartes, Discourse on Method \n\nIn programming, as in life, big, general problems are very hard to solve effectively. \nInstead, the goal is to break a problem down into smaller pieces that may actually be solvable. \n\n::: callout-caution\n### Example: Exhaustion\n\nThis example inspired by @grimesThis500YearOldPiece2019. \n\n::: panel-tabset\n\n#### General problem\n\n\"I'm exhausted all the time\"    \nOk, so this is a problem that many of us have from time to time (or all the time). \nIf we get a little bit more specific at outlining the problem, though, we can sometimes get a bit more insight into how to solve it.\n\n#### Specific problem\n\n\"I wake up in the morning and I don't have any energy to do anything. \nI want to go back to sleep, but I have too much to do to actually give in and sleep. \nI spend my days worrying about how I'm going to get all of the things on my to-do list done, and then I lie awake at night thinking about how many things there are to do tomorrow. \nI don't have time for hobbies or exercise, so I drink a lot of coffee instead to make it through the day.\"    \nThis is a much more specific list of issues, and some of these issues are actually things we can approach separately.\n\n#### Subproblems\n\nMoving through the list in the previous tab, we can isolate a few issues. \nSome of these issues are undoubtedly related to each other, but we can approach them separately (for the most part).\n\n1. Poor quality sleep (tired in the morning, lying awake at night)\n2. Too many things to do (to-do list)\n3. Chemical solutions to low energy (coffee during the day)\n4. Anxiety about completing tasks (worrying, insomnia)\n5. Lack of personal time for hobbies or exercise\n\n\n#### Brainstorm\n\n1. Get a check-up to rule out any other issues that could cause sleep quality degradation - depression, anxiety, sleep apnea, thyroid conditions, etc.\n    - Ask the doctor about taking melatonin supplements for a short time to ensure that sleep starts off well (note, don't take medical advice from a stats textbook!)\n2. Reformat your to-do list:\n    - Set time limits for things on the to-do list \n    - Break the to-do list into smaller, manageable tasks that can be accomplished within a relatively short interval - such as an hour\n    - Sort the to-do list by priority and level of \"fun\" so that each day has a few hard tasks and a couple of easy/fun tasks. \n    Do the hard tasks first, and use the easy/fun tasks as a reward.\n3. Set a time limit for caffeine (e.g. no coffee after noon) so that caffeine doesn't contribute to poor quality sleep\n4. Address anxiety with medication (from 1), scheduled time for mindfulness meditation, and/or self-care activities\n5. Scheduling time for exercise/hobbies\n    - scheduling exercise in the morning to take advantage of the endorphins generated by working out\n    - scheduling hobbies in the evening to reward yourself for a day's work and wind down work well before bedtime\n        \n#### Subproblem solutions\nWhen the sub-problem has a viable solution, move on to the next sub-problem. \nDon't try to tackle everything at once. \nHere, that might look like this list, where each step is taken separately and you give each thing a few days to see how it affects your sleep quality.\nIn programming, of course, this list would perhaps be a bit more sequential, but real life is messy and the results take a while to populate.\n\n  - [1] Make the doctor's appointment.\n  - [5] While waiting for the appointment, schedule exercise early in the day and hobbies later in the day to create a \"no-work\" period before bedtime.\n  - [1] Go to the doctor's appointment, follow up with any concerns.\n      - [1] If doctor approves, start taking melatonin according to directions\n  - [2] Work on reformatting the to-do list into manageable chunks. Schedule time to complete chunks using your favorite planning method.\n  - [4] If anxiety is still an issue after following up with the doctor, add some mindfullness meditation or self-care to the schedule in the mornings or evenings.\n  - [3] If sleep quality is still an issue, set a time limit for caffeine\n  - [2] Revise your to-do list and try a different tactic if what you were trying didn't work.\n\n:::\n:::\n\n\n## Minimal Working (or Reproducible) Examples\n\n::: column-margin\n![The reprex R package will help you make a reproducible example (drawing by Allison Horst)](../images/gen-prog/reprex.png)\n:::\n\nIf all else has failed, and you can't figure out what is causing your error, it's probably time to ask for help. \nIf you have a friend or buddy that knows the language you're working in, by all means ask for help sooner - use them as a rubber duck if you have to. \nBut when you ask for help online, often you're asking people who are much more knowledgeable about the topic - members of R core and really famous python developers browse stackoverflow and may drop in and help you out. \nUnder those circumstances, it's better to make the task of helping you as easy as possible because it shows respect for their time. \nThe same thing goes for your supervisors and professors. \n\n\n\nThere are numerous resources for writing what's called a \"minimal working example\", \"reproducible example\" (commonly abbreviated reprex), or MCVE (minimal complete verifiable example). \nMuch of this is lifted directly from the StackOverflow post describing a [minimal reproducible example](https://stackoverflow.com/help/minimal-reproducible-example).\n\nThe goal is to reproduce the error message with information that is \n\n- **minimal** - as little code as possible to still reproduce the problem\n- **complete** - everything necessary to reproduce the issue is contained in the description/question\n- **reproducible** - test the code you provide to reproduce the problem. \n\nYou should format your question to make it as easy as possible to help you. \nMake it so that code can be copied from your post directly and pasted into a terminal. \nDescribe what you see and what you'd hope to see if the code were working. \n\n::: callout-note\n### Other Minimum Working Example/Reprex resources\n\n- [reprex package: Do's and Don'ts](https://reprex.tidyverse.org/articles/reprex-dos-and-donts.html)\n- [How to use the reprex package](https://reprex.tidyverse.org/articles/articles/learn-reprex.html) - vignette with videos from Jenny Bryan\n- [reprex magic - Vignette adapted from a blog post by Nick Tierney](https://reprex.tidyverse.org/articles/articles/magic-reprex.html)\n:::\n\n::: callout-caution\n### Example: MWEs \n\nNote: You don't need to know anything about SAS to understand this example.\n\n::: panel-tabset\n\n#### SAS markdown\nA long time ago, when this book covered R and SAS, I had issues with SAS graphs rendering in black and white most of the time. \n\nI started debugging the issue with the following code chunk: \n\n```{{r sas-cat-aes-map-07, engine=\"sashtml\", engine.path=\"sas\", fig.path = \"image/\"}}\nlibname classdat \"sas/\";\n\nPROC SGPLOT data=classdat.fbiwide; \nSCATTER x = Population y = Assault /\n  markerattrs=(size=8pt symbol=circlefilled) \n  group = Abb; /* maps to point color by default */\nRUN;\nQUIT; \n  \nPROC SGPLOT data=classdat.fbiwide NOAUTOLEGEND; /* dont generate a legend */\nSCATTER x = Population y = Assault /\n  markercharattrs=(size=8) \n  markerchar = Abb /* specify marker character variable */\n    group = Abb\n  ; \nRUN;\nQUIT; \n```\n\n\nAfter running the code separately in SAS and getting a figure that looked like what I'd expected, I set out to construct a reproducible example so that I could post to the [SASmarkdown github issues page](https://github.com/Hemken/SASmarkdown/issues/14) and ask for help.\n\nThe first thing I did was strip out all of the extra stuff that didn't need to be in the chunk - this chunk generates 2 pictures; I only need one. \nThis chunk requires the fbiwide data from the `classdata` R package (that I exported to CSV); I replaced it with a dataset in the `sashelp` library.\n\nWhen I was done, the chunk looked like this:\n\n```\nPROC SGPLOT data=sashelp.snacks;\nSCATTER x = date y = QtySold /\n  markerattrs=(size=8pt symbol=circlefilled)\n  group = product; /* maps to point color by default */\nRUN;\nQUIT;\n```\n\nThen, I started constructing my reproducible example. \nI ran `?sas_enginesetup` to get to a SASmarkdown help page, because I remembered it had a nice way to generate and run markdown files from R directly (without saving the Rmd file). \n\nI copied the example from that page:\n```\nindoc <- '\n---\ntitle: \"Basic SASmarkdown Doc\"\nauthor: \"Doug Hemken\"\noutput: html_document\n---\n\n# I've deleted the intermediate chunks because they screw \n# everything up when I print this chunk out\n'\nknitr::knit(text=indoc, output=\"test.md\")\nrmarkdown::render(\"test.md\")\n```\n\nThen, I created several chunks which would do the following:\n1. Write the minimal example SAS code above to a [file](files/reprex.sas)\n2. Call that file in a SASmarkdown chunk using the `%include` macro, which dumps the listed file into the SAS program. This generates the [plot](files/SASmarkdown-reprex/unnamed-chunk-1.png) using SASmarkdown.\n3. Call the file using SAS batch mode    \n(this runs the code and produces a [plot](files/SASmarkdown-reprex/SGPlot.png) outside of SASmarkdown, to prove that the issue is SASmarkdown itself)\n\nFinally, I included the image generated from the batch mode call manually.\n\nYou can see the resulting code [here](https://github.com/Hemken/SASmarkdown/issues/14).\n\nI pasted my example into the issues page, and then included some additional information: \n\n1. A screenshot of the rendered page\n2. The image files themselves\n3. A description of what happened\n4. My suspicions (some obvious option I'm missing?)\n5. An additional line of R code that would delete any files created if someone ran my example. Because file clutter sucks.\n\nThis process took me about 45 minutes, but that was still much shorter than the time I'd spent rerunning code trying to get it to work with no success. \n\nIn less than 24 hours, the package maintainer responded with a (admittedly terse) explanation of what he thought caused the problem. \nI had to do some additional research to figure out what that meant, but once I had my reproducible example working in color, I posted that code (so that anyone else with the same problem would know what to do).\n\nThen, I had to tinker with the book a bit to figure out if there were easier ways to get the same result.\nThe end result, though, was that I got what I wanted - color figures throughout the book!\n\n#### Python/Quarto\n\nWhile converting the book from Rmarkdown to quarto, I ran into an issue setting up GitHub Actions (basically, when I push changes, GitHub rebuilds the book from scratch automatically). \n\n\nI found an issue describing the same segfault issue I had been getting, and so I made a [post there](https://github.com/rstudio/reticulate/issues/1133) with a new github repository containing a [minimal working example](https://github.com/srvanderplas/test-quarto) that I set up to test the problem. \n\nWithin 24h, I had gotten replies from people working at RStudio, and one of them had [diagnosed the problem](https://github.com/rstudio/reticulate/issues/1133#issuecomment-1021783041). \nAfter I asked a few more questions, one of them submitted a pull request to my repository with a solution.\n\nI didn't know enough python or enough about GitHub Actions to diagnose the problem myself, but because I managed to create a reproducible example, I got the answers I needed from people with more experience.\n\n:::\n\n:::\n\n::: callout-tip\n### Try It Out \n\nUse [this list of StackOverflow posts](files/Debugging_exercise.html) to try out your new debugging techniques. \nCan you figure out what's wrong? \nWhat information would you need from the poster in order to come up with a solution?\nHow much time did you spend trying to figure out what the poster was actually asking?\n:::\n\n\n\n## Debugging Tools\n\nNow that we've discussed general strategies for debugging that will work in any language, lets get down to the dirty details of debugging. \n\n### Low tech debugging with print() and other tools\nSometimes called \"tracing\" techniques, the most common, universal, and low tech strategy for debugging involves scattering messages throughout your code. \nWhen the code is executed, you get a window into what the variables look like during execution.\n\nThis is called **print debugging** and it is an incredibly useful tool.\n\n::: callout-caution\n#### Example: Nested Functions\n\n::: panel-tabset\n#### R\nImagine we start with this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1\ny = 2\nz = 0\n\naa <- function(x) {\n  bb <- function(y) {\n    cc <- function(z) {\n      z + y\n    }\n    cc(3) + 2\n  }\n  x + bb(4)\n}\n\naa(5)\n## [1] 14\n```\n:::\n\n\n\nand the goal is to understand what's happening in the code. We might add some lines:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1\ny = 2\nz = 0\n\naa <- function(x) {\n  print(paste(\"Entering aa(). x = \", x))\n  bb <- function(y) {\n    print(paste(\"Entering bb(). x = \", x, \"y = \", y))\n    cc <- function(z) {\n      print(paste(\"Entering cc(). x = \", x, \"y = \", y, \"z = \", z))\n      cres <- z + y\n      print(paste(\"Returning\", cres, \"from cc()\"))\n      cres\n    }\n    bres <- cc(3) + 2\n    print(paste(\"Returning\", bres, \"from bb()\"))\n    bres\n  }\n  ares <- x + bb(4)\n  print(paste(\"Returning\",ares, \"from aa()\"))\n  ares\n}\n\naa(5)\n## [1] \"Entering aa(). x =  5\"\n## [1] \"Entering bb(). x =  5 y =  4\"\n## [1] \"Entering cc(). x =  5 y =  4 z =  3\"\n## [1] \"Returning 7 from cc()\"\n## [1] \"Returning 9 from bb()\"\n## [1] \"Returning 14 from aa()\"\n## [1] 14\n```\n:::\n\n\n\n#### Python\nImagine we start with this:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 1\ny = 2\nz = 0\n\ndef aa(x):\n  def bb(y):\n    def cc(z):\n      return z + y\n    return cc(3) + 2\n  return x + bb(4)\n\naa(5)\n## 14\n```\n:::\n\n\n\n\nand the goal is to understand what's happening in the code. We might add some lines:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 1\ny = 2\nz = 0\n\ndef aa(x):\n  print(\"Entering aa(). x = \" + str(x))\n  def bb(y):\n    print(\"Entering bb(). x = \" + str(x) + \", y = \" + str(y))\n    def cc(z):\n      print(\"Entering cc(). x = \" + str(x) + \", y = \" + str(y) + \", z = \" + str(z))\n      cres = z + y\n      print(\"Returning \" + str(cres) + \" from cc()\")\n      return cres\n    bres = cc(3) + 2\n    print(\"Returning \" + str(bres) + \" from bb()\")\n    return bres\n  ares = x + bb(4)\n  print(\"Returning \" + str(ares) + \" from aa()\")\n  return ares\n\naa(5)\n## Entering aa(). x = 5\n## Entering bb(). x = 5, y = 4\n## Entering cc(). x = 5, y = 4, z = 3\n## Returning 7 from cc()\n## Returning 9 from bb()\n## Returning 14 from aa()\n## 14\n```\n:::\n\n\n:::\n\n:::\n\nFor more complex data structures, it can be useful to add `str()`, `head()`, or `summary()` functions. \n\n::: callout-caution\n#### Real world example: Web Scraping\n\nIn fall 2020, I wrote a webscraper to get election polling data from the RealClearPolitics site as part of the [`electionViz` package](github.com/heike/electionViz).\nI wrote the function `search_for_parent()` to get the parent HTML tag which matched the \"tag\" argument, that had the \"node\" argument as a descendant. \nI used print debugging to show the sequence of tags on the page.\n\nI was assuming that the order of the parents would be \"html\", \"body\", \"div\", \"table\", \"tbody\", \"tr\" - descending from outer to inner (if you know anything about HTML/XML structure). \n\nTo prevent the site from changing on me (as websites tend to do...), I've saved the HTML file [here](../files/realclearpolitics_frag.html).\n\n::: panel-tabset\n##### R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xml2) # read html\n\nsearch_for_parent <- function(node, tag) {\n  # Get all of the parent nodes \n  parents <- xml2::xml_parents(node)\n  # Get the tags of every parent node\n  tags <- purrr::map_chr(parents, rvest::html_name)\n  print(tags)\n  \n  # Find matching tags\n  matches <- which(tags == tag)\n  print(matches)\n  \n  # Take the minimum matching tag\n  min_match <- min(matches)\n  if (length(matches) == 1) return(parents[min_match]) else return(NULL)\n}\n\npage <- read_html(\"shorturl.at/jkS59\")\n## Error: 'shorturl.at/jkS59' does not exist in current working directory ('/home/susan/Projects/Class/stat-computing-r-python/part-gen-prog').\n# find all poll results in any table\npoll_results <- xml_find_all(page, \"//td[@class='lp-results']\") \n## Error in UseMethod(\"xml_find_all\"): no applicable method for 'xml_find_all' applied to an object of class \"function\"\n# find the table that contains it\nsearch_for_parent(poll_results[1], \"table\") \n## Error in nodeset_apply(x, function(x) .Call(node_parents, x)): object 'poll_results' not found\n```\n:::\n\n\n\n##### Python\n\nYou may need to `pip install lxml requests bs4` to run this code. \n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# !pip install lxml requests bs4\nfrom bs4 import BeautifulSoup\nimport requests as req\nimport numpy as np\n\n\ndef search_for_parent(node, tag):\n  # Get all of the parent nodes\n  parents = node.find_parents()\n  # get tag type for each parent node\n  tags = [x.name for x in parents]\n  print(tags)\n  \n  # Find matching tags\n  matches = np.array([i for i, val in enumerate(tags) if val == tag])\n  print(matches)\n  \n  # Take the minimum matching tag\n  min_match = np.min(matches)\n  if matches.size == 1:\n    ret = parents[min_match]\n  \n  return ret\n\n\nhtml_file = open('shorturl.at/jkS59', 'r')\n## Error in py_call_impl(callable, dots$args, dots$keywords): FileNotFoundError: [Errno 2] No such file or directory: 'shorturl.at/jkS59'\npage = html_file.read() \n# Read the page as HTML\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'html_file' is not defined\nsoup = BeautifulSoup(page, 'html')\n# Find all poll results in any table\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'page' is not defined\npoll_results = soup.findAll('td', {'class': 'lp-results'})\n# Find the table that contains the first poll result\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'soup' is not defined\nsearch_for_parent(poll_results[0], 'table')\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'poll_results' is not defined\n```\n:::\n\n\n:::\n\nBy printing out all of the tags that contain `node`, I could see the order -- inner to outer. \nI asked the function to return the location of the first table node, so the index (2nd value printed out) should match table in the character vector that was printed out first. \nI could then see that the HTML node that is returned is in fact the table node. \n\n:::\n\n::: callout-tip\n#### Try it out: Hurricanes in R\n\nNot all bugs result in error messages, unfortunately, which makes higher-level techniques like `traceback()` less useful. \nThe low-tech debugging tools, however, still work wonderfully. \n\n::: panel-tabset\n\n##### Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(magrittr)\nlibrary(maps)\nlibrary(ggthemes)\nworldmap <- map_data(\"world\")\n\n# Load the data\ndata(storms, package = \"dplyr\")\n```\n:::\n\n\n\n##### Buggy code\n\nThe code below is supposed to print out a map of the tracks of all hurricanes of a specific category, 1 to 5, in 2013. Use print statements to figure out what's wrong with my code. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make base map to be used for each iteration\nbasemap <-  ggplot() + \n  # Country shapes\n  geom_polygon(aes(x = long, y = lat, group = group), \n               data = worldmap, fill = \"white\", color = \"black\") + \n  # Zoom in \n  coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + \n  # Don't need scales b/c maps provide their own geographic context...\n  theme_map()\n\nfor (i in 1:5) {\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(status == i)\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  print(plot)\n}\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/map-hurricane-tracks-1.pdf){fig-pos='H' width=18%}\n:::\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/map-hurricane-tracks-2.pdf){fig-pos='H' width=18%}\n:::\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/map-hurricane-tracks-3.pdf){fig-pos='H' width=18%}\n:::\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/map-hurricane-tracks-4.pdf){fig-pos='H' width=18%}\n:::\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/map-hurricane-tracks-5.pdf){fig-pos='H' width=18%}\n:::\n:::\n\n\n\n##### Solution 1: Identification\n\nFirst, lets split the setup from the loop. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make base map to be used for each iteration\nbasemap <-  ggplot() + \n  # Country shapes\n  geom_polygon(aes(x = long, y = lat, group = group), \n               data = worldmap, fill = \"white\", color = \"black\") + \n  # Zoom in \n  coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + \n  # Don't need scales b/c maps provide their own geographic context...\n  theme_map()\n\nprint(basemap) # make sure the basemap is fine\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/map-hurricane-tracks-setup-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n\n# Load the data\ndata(storms, package = \"dplyr\")\n\nstr(storms) # make sure the data exists and is formatted as expected\n## tibble [11,859 x 13] (S3: tbl_df/tbl/data.frame)\n##  $ name                        : chr [1:11859] \"Amy\" \"Amy\" \"Amy\" \"Amy\" ...\n##  $ year                        : num [1:11859] 1975 1975 1975 1975 1975 ...\n##  $ month                       : num [1:11859] 6 6 6 6 6 6 6 6 6 6 ...\n##  $ day                         : int [1:11859] 27 27 27 27 28 28 28 28 29 29 ...\n##  $ hour                        : num [1:11859] 0 6 12 18 0 6 12 18 0 6 ...\n##  $ lat                         : num [1:11859] 27.5 28.5 29.5 30.5 31.5 32.4 33.3 34 34.4 34 ...\n##  $ long                        : num [1:11859] -79 -79 -79 -79 -78.8 -78.7 -78 -77 -75.8 -74.8 ...\n##  $ status                      : chr [1:11859] \"tropical depression\" \"tropical depression\" \"tropical depression\" \"tropical depression\" ...\n##  $ category                    : Ord.factor w/ 7 levels \"-1\"<\"0\"<\"1\"<\"2\"<..: 1 1 1 1 1 1 1 1 2 2 ...\n##  $ wind                        : int [1:11859] 25 25 25 25 25 25 25 30 35 40 ...\n##  $ pressure                    : int [1:11859] 1013 1013 1013 1013 1012 1012 1011 1006 1004 1002 ...\n##  $ tropicalstorm_force_diameter: int [1:11859] NA NA NA NA NA NA NA NA NA NA ...\n##  $ hurricane_force_diameter    : int [1:11859] NA NA NA NA NA NA NA NA NA NA ...\n```\n:::\n\n\n\nEverything looks ok in the setup chunk...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  print(paste0(\"Category \", i, \" storms\"))\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(status == i)\n  \n  print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n        # str(subdata) works too, but produces more clutter. I started\n        # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  # print(plot) # Don't print plots - clutters up output at the moment\n}\n## [1] \"Category 1 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n## [1] \"Category 2 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n## [1] \"Category 3 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n## [1] \"Category 4 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n## [1] \"Category 5 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n```\n:::\n\n\n\nOk, so from this we can see that something is going wrong with our filter statement - we have no rows of data.\n\n##### Solution 2: Fixing\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(storms)\n## # A tibble: 6 x 13\n##   name   year month   day  hour   lat  long status categ~1  wind press~2 tropi~3\n##   <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <chr>  <ord>   <int>   <int>   <int>\n## 1 Amy    1975     6    27     0  27.5 -79   tropi~ -1         25    1013      NA\n## 2 Amy    1975     6    27     6  28.5 -79   tropi~ -1         25    1013      NA\n## 3 Amy    1975     6    27    12  29.5 -79   tropi~ -1         25    1013      NA\n## 4 Amy    1975     6    27    18  30.5 -79   tropi~ -1         25    1013      NA\n## 5 Amy    1975     6    28     0  31.5 -78.8 tropi~ -1         25    1012      NA\n## 6 Amy    1975     6    28     6  32.4 -78.7 tropi~ -1         25    1012      NA\n## # ... with 1 more variable: hurricane_force_diameter <int>, and abbreviated\n## #   variable names 1: category, 2: pressure, 3: tropicalstorm_force_diameter\n```\n:::\n\n\n\nWhoops. I meant \"category\" when I typed \"status\". \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  print(paste0(\"Category \", i, \" storms\"))\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(category == i)\n  \n  print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n        # str(subdata) works too, but produces more clutter. I started\n        # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  # print(plot) # Don't print plots - clutters up output at the moment\n}\n## [1] \"Category 1 storms\"\n## [1] \"subdata dims: nrow 13 ncol 13\"\n## [1] \"Category 2 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n## [1] \"Category 3 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n## [1] \"Category 4 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n## [1] \"Category 5 storms\"\n## [1] \"subdata dims: nrow 0 ncol 13\"\n```\n:::\n\n\n\nOk, that's something, at least. \nWe now have some data for category 1 storms...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(storms, year == 2013) %>%\n  # Get max category for each named storm\n  group_by(name) %>%\n  filter(category == max(category)) %>%\n  ungroup() %>%\n  # See what categories exist\n  select(name, category) %>%\n  unique()\n## # A tibble: 14 x 2\n##    name      category\n##    <chr>     <ord>   \n##  1 Andrea    0       \n##  2 Barry     0       \n##  3 Chantal   0       \n##  4 Dorian    0       \n##  5 Erin      0       \n##  6 Fernand   0       \n##  7 Gabrielle 0       \n##  8 Eight     -1      \n##  9 Humberto  1       \n## 10 Ingrid    1       \n## 11 Jerry     0       \n## 12 Karen     0       \n## 13 Lorenzo   0       \n## 14 Melissa   0\n```\n:::\n\n\n\nIt looks like 2013 was just an incredibly quiet year for tropical activity. \n\n##### Solution 3: Verifying\n\n2013 may have been a quiet year for tropical activity in the Atlantic, but 2004 was not. \nSo let's just make sure our code works by checking out 2004. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  print(paste0(\"Category \", i, \" storms\"))\n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2004) %>%\n    filter(category == i)\n  \n  print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n        # str(subdata) works too, but produces more clutter. I started\n        # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  print(plot) # Don't print plots - clutters up output at the moment\n}\n## [1] \"Category 1 storms\"\n## [1] \"subdata dims: nrow 45 ncol 13\"\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/hurricane-tracks-debugging-4-1.pdf){fig-pos='H'}\n:::\n\n```\n## [1] \"Category 2 storms\"\n## [1] \"subdata dims: nrow 39 ncol 13\"\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/hurricane-tracks-debugging-4-2.pdf){fig-pos='H'}\n:::\n\n```\n## [1] \"Category 3 storms\"\n## [1] \"subdata dims: nrow 29 ncol 13\"\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/hurricane-tracks-debugging-4-3.pdf){fig-pos='H'}\n:::\n\n```\n## [1] \"Category 4 storms\"\n## [1] \"subdata dims: nrow 32 ncol 13\"\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/hurricane-tracks-debugging-4-4.pdf){fig-pos='H'}\n:::\n\n```\n## [1] \"Category 5 storms\"\n## [1] \"subdata dims: nrow 12 ncol 13\"\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/hurricane-tracks-debugging-4-5.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nIf we want to only print informative plots, we could add an if statement. \nNow that the code works, we can also comment out our print() statements (we could delete them, too, depending on whether we anticipate future problems with the code). \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  # print(paste0(\"Category \", i, \" storms\"))\n  \n  # Subset the data\n  subdata <- storms %>%\n    filter(year == 2013) %>%\n    filter(category == i)\n  \n  # print(paste0(\"subdata dims: nrow \", nrow(subdata), \" ncol \", ncol(subdata)))\n  #       # str(subdata) works too, but produces more clutter. I started\n  #       # with str() and moved to dim() when I saw the problem\n  \n  # Plot the data - path + points to show the observations\n  plot <- basemap +\n    geom_path(aes(x = long, y = lat, color = name), data = subdata) + \n    geom_point(aes(x = long, y = lat, color = name), data = subdata) + \n    ggtitle(paste0(\"Category \", i, \" storms in 2013\"))\n  \n  if (nrow(subdata) > 0) print(plot) \n}\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/hurricane-tracks-debugging-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n:::\n\nOnce you've found your problem, go back and delete or comment out your print statements, as they're no longer necessary. \nIf you think you may need them again, comment them out, otherwise, just delete them so that your code is neat, clean, and concise.\n\n\n### After an error has occurred - `traceback()`\n\n`traceback()` can help you narrow down where an error occurs by taking you through the series of function calls that led up to the error. \nThis may help you identify which function is actually causing the problem, which is especially useful when you have nested functions or are using package functions that depend on other packages.\n\n::: callout-demo\n#### Using traceback\n\n::: panel-tabset\n##### R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naa <- function(x) {\n  bb <- function(y) {\n    cc <- function(z) {\n     stop('there was a problem')  # This generates an error\n    }\n    cc()\n  }\n  bb()\n}\n\naa()\n## Error in cc(): there was a problem\n```\n:::\n\n\n\nFor more information, you could run traceback\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntraceback()\n```\n:::\n\n\n\nWhich will provide the following output:\n```\n4: stop(\"there was a problem\") at #4\n3: c() at #6\n2: b() at #8\n1: a()\n```\n\nReading through this, we see that a() was called, b() was called, c() was called, and then there was an error. It's even kind enough to tell us that the error occurred at line 4 of the code. \n\nIf you are running this code interactively in RStudio, it's even easier to run `traceback()` by clicking on the \"Show Traceback\" option that appears when there is an error.\n\n![Both Show Traceback and Rerun with Debug are useful tools](../images/gen-prog/Rstudio_rerun_traceback.png){fig-width=\"50%\"\nfig-alt=\"A screenshot from RStudio reading 'Error in c(): there was a problem', with buttons 'Show Traceback' and 'Rerun with Debug'\"}\n\nIf you are using `source()` to run the code in Rstudio, it will even provide a link to the file and line location of the error. \n![The output of `source(\"code/07_debug_ex.R\")` as run in RStudio. The traceback() function information contains links to the files of the functions causing the error. For instance, 07_debug_ex.R#4 text is a link to line 4 of the file.](../images/gen-prog/Rstudio_rerun_traceback_source.png)\n\n\n##### Python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport sys,traceback\n\ndef aa(x):\n  def bb(y):\n    def cc(z):\n      try: \n        return y + z + tuple()[0] # This generates an error\n      except IndexError:\n        exc_type, exc_value, exc_tb = sys.exc_info()\n        traceback.print_exception(exc_type, exc_value, exc_tb, file = sys.stdout)\n    return cc(3) + 2\n  return x + bb(4)\n\naa(5)\n## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'\n```\n:::\n\n\n\nPython's [traceback](https://docs.python.org/3/library/traceback.html) information is a bit more low-level and requires a bit more from the programmer than R's version.\n\n:::\n\n:::\n\n### Interactive Debugging\n\n::: youtube-video-container\n<iframe width=\"100%\" height=\"auto\" src=\"https://www.youtube.com/embed/dA2ce5SA3C8\" title=\"Using debug() in R\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n:::\n\n::: panel-tabset\n\n#### R `browser()`\n\nThe `browser()` function is useful for debugging your own code. \nIf you're writing a function and something isn't working quite right, you can insert a call to `browser()` in that function, and examine what's going on. \n\n::: callout-caution\n##### Example : browser()\n\nSuppose that I want to write a function that will plot an xkcd comic in R. \n\nI start with \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(png)\nlibrary(xml2)\nlibrary(dplyr)\n\n# get the most current xkcd\nget_xkcd <- function() {\n  url <- \"http://xkcd.com\"\n  page <- read_html(url)\n  # Find the comic\n  image <- xml_find_first(page, \"//div[@id='comic']/img\") %>%\n    # pull the address out of the tag\n    xml_attr(\"src\")\n  \n  \n  readPNG(source = image)\n}\n\nget_xkcd() %>%\n  as.raster() %>%\n  plot()\n## Error in readPNG(source = image): unable to open //imgs.xkcd.com/comics/washing_machine_settings.png\n```\n:::\n\n\n\nHere's the final function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(png)\nlibrary(xml2)\n\n# get the most current xkcd\nget_xkcd <- function() {\n  \n  url <- \"http://xkcd.com\"\n  page <- read_html(url)\n  # Find the comic\n  image <- xml_find_first(page, \"//div[@id='comic']/img\") %>%\n    # pull the address out of the tag\n    xml_attr(\"src\")\n  \n  # Fix image address so that we can access the image\n  image <- substr(image, 3, nchar(image))\n  \n  # Download the file to a temp file and read from there\n  file_location <- tempfile(fileext = \".png\")\n  download.file(image, destfile = file_location, quiet = T)\n  \n  readPNG(source = file_location)\n}\n\nget_xkcd() %>%\n  as.raster() %>%\n  plot()\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/browser-demo-2-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n\n#### Python\n\nIn python, the equivalent interactive debugger is `ipdb`. You can install it with `pip install ipdb`.\n\nIf you want to run Python in the interactive ipython console, then you can invoke the ipdb debugging with `%debug get_xkcd()`. \nThis is similar to `browser()` in R. \nIf you're working in Python in RStudio, though, you have to get into debug mode in a more involved way.\n\nTo run code using `ipdb` when your code hits an error, add `from ipdb import launch_ipdb_on_exception` to the top of your python code chunk. \nThen, at the bottom, put any lines that may trigger the error after these two lines:\n\n```\nif __name__ == \"__main__\":\n  with launch_ipdb_on_exception():\n    <your properly indented code goes here>\n```\n\nThis ensures that ipdb is launched when an error is reached.\n\n\n::: callout-caution\n##### Example using `ipdb`\nSuppose that I want to write a function that will plot an xkcd comic in python. \n\nI start with \n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom bs4 import BeautifulSoup\nimport urllib.request # work with html\nfrom PIL import Image # work with images\nimport numpy as np\n\n# importing pyplot and image from matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.image as img\n\n# get the most current xkcd\ndef get_xkcd():\n  url = \"http://xkcd.com\"\n  \n  # Get the URL\n  html_file = urllib.request.urlopen(url)\n  page = html_file.read() \n  decode_page = page.decode(\"utf8\")\n  \n  # Read the page as HTML\n  soup = BeautifulSoup(decode_page, 'html')\n  \n  # Get the comic src from the img tag\n  imlink = soup.select('#comic > img')[0].get('src')\n  # Format as a numpy array\n  image = np.array(Image.open(urllib.request.urlopen(imlink)))\n  \n  return image\n\nplt.imshow(get_xkcd())\n## Error in py_call_impl(callable, dots$args, dots$keywords): ValueError: unknown url type: '//imgs.xkcd.com/comics/washing_machine_settings.png'\nplt.show()\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/browser-demo-py-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nHere's the final function\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom bs4 import BeautifulSoup\nimport urllib.request # work with html\nfrom PIL import Image # work with images\nimport numpy as np\n\n# importing pyplot and image from matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.image as img\n\n# get the most current xkcd\ndef get_xkcd():\n  url = \"http://xkcd.com\"\n  \n  # Get the URL\n  html_file = urllib.request.urlopen(url)\n  page = html_file.read() \n  decode_page = page.decode(\"utf8\")\n  \n  # Read the page as HTML\n  soup = BeautifulSoup(decode_page, 'html')\n  \n  # Get the comic src from the img tag\n  imlink = soup.select('#comic > img')[0].get('src')\n  # Format as a numpy array\n  image = np.array(Image.open(urllib.request.urlopen('https:' + imlink)))\n  \n  return image\n\nplt.imshow(get_xkcd())\nplt.show()\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/browser-demo-py2-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n::: youtube-video-container\n<iframe width=\"100%\" height=\"auto\" src=\"https://www.youtube.com/embed/zGRsLLWGVR0\" title=\"Using ipdb in python\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n:::\n\n:::\n\n:::\n\n::: callout-tip\n#### Try it out \n\n::: panel-tabset\n\n##### Problem\nEach xkcd has a corresponding ID number (ordered sequentially from 1 to 2722 at the time this was written). \nModify the XKCD functions above to make use of the id parameter, so that you can pass in an ID number and get the relevant comic. \n\nUse interactive debugging tools to help you figure out what logic you need to add. \nYou should not need to change the web scraping code - the only change should be to the URL. \n\nWhat things might you add to make this function \"defensive programming\" compatible? \n\n##### R Solution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the most current xkcd or the specified number\nget_xkcd <- function(id = NULL) {\n  if (is.null(id)) {\n    # Have to get the location of the image ourselves\n    url <- \"http://xkcd.com\"\n  } else if (is.numeric(id)) {\n    url <- paste0(\"http://xkcd.com/\", id, \"/\")\n  } else {\n    # only allow numeric or null input\n    stop(\"To get current xkcd, pass in NULL, otherwise, pass in a valid comic number\")\n  }\n\n  page <- read_html(url)\n  # Find the comic\n  image <- xml_find_first(page, \"//div[@id='comic']/img\") %>%\n    # pull the address out of the tag\n    xml_attr(\"src\")\n  # Fix image address so that we can access the image\n  image <- substr(image, 3, nchar(image)) # cut the first 2 characters off\n\n  # make temp file\n  location <- tempfile(fileext = \"png\")\n  download.file(image, destfile = location, quiet = T)\n\n  # This checks to make sure we saved the file correctly\n  if (file.exists(location)) {\n    readPNG(source = location)\n  } else {\n    # Give a good informative error message\n    stop(paste(\"Something went wrong saving the image at \", image, \" to \", location))\n  }\n}\n\nget_xkcd(2259) %>%\n  as.raster() %>% \n  plot()\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/xkcd-tryitout-solution-5.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n##### Python Solution\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom bs4 import BeautifulSoup\nimport urllib.request # work with html\nfrom PIL import Image # work with images\nimport numpy as np\n\n# importing pyplot and image from matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.image as img\n\n# get the most current xkcd\ndef get_xkcd(id=''):\n  image = 0 # Defining a placeholder\n  \n  if id == '':\n    # Have to get the location of the image ourselves\n    url = \"http://xkcd.com\"\n  elif id.isnumeric():\n    url = \"http://xkcd.com/\" + id + \"/\"\n  else:\n    # only allow numeric or null input\n    raise TypeError(\"To get current xkcd, pass in an empty string, otherwise, pass in a valid integer comic number\")\n  \n  # Print debugging left in for your amusement\n  # print(type(id))\n  \n  # Get the URL\n  html_file = urllib.request.urlopen(url)\n  page = html_file.read() \n  decode_page = page.decode(\"utf8\")\n  \n  # Read the page as HTML\n  soup = BeautifulSoup(decode_page, 'html')\n  \n  # Get the comic src from the img tag\n  imnode = soup.select('#comic > img')\n  \n  try:\n    imlink = imnode[0].get('src')\n  except:\n    raise Exception(\"No comic could be found with number \" + id + \" (url = \"+ url+ \" )\")\n  \n  try: \n    # Format as a numpy array\n    image = np.array(Image.open(urllib.request.urlopen('https:' + imlink)))\n    return image\n  except: \n    raise Exception(\"Reading the image failed. Check to make sure an image exists at \" + url)\n    return(None)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nres = get_xkcd('')\nplt.imshow(res)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](06-debugging_files/figure-pdf/tryitout-xkcd-py2-1.pdf){fig-pos='H'}\n:::\n\n```{.python .cell-code}\nres = get_xkcd('3000')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in py_call_impl(callable, dots$args, dots$keywords): urllib.error.HTTPError: HTTP Error 404: Not Found\n```\n:::\n\n```{.python .cell-code}\nres = get_xkcd('abcd')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in py_call_impl(callable, dots$args, dots$keywords): TypeError: To get current xkcd, pass in an empty string, otherwise, pass in a valid integer comic number\n```\n:::\n:::\n\n\n\n\n:::\n\n:::\n\n### R `debug()`\n\nIn the `traceback()` Rstudio output, the other option is \"rerun with debug\". \nIn short, debug mode opens up a new interactive session inside the function evaluation environment. \nThis lets you observe what's going on in the function, pinpoint the error (and what causes it), and potentially fix the error, all in one neat workflow. \n\n`debug()` is most useful when you're working with code that you didn't write yourself. \nSo, if you can't change the code in the function causing the error, `debug()` is the way to go. Otherwise, using `browser()` is generally easier. \nEssentially, `debug()` places a `browser()` statement at the first line of a function, but without having to actually alter the function's source code. \n\n::: {.callout-caution collapse=\"true\"}\n#### `debug()` example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\n\ntmp <- lm(Species ~ ., data = iris)\nsummary(tmp)\n## \n## Call:\n## lm(formula = Species ~ ., data = iris)\n## \n## Residuals:\n## Error in quantile.default(resid): (unordered) factors are not allowed\n```\n:::\n\n\nWe get this weird warning, and then an error about factors when we use summary() to look at the coefficients. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug(lm) # turn debugging on\n\n\ntmp <- lm(Species ~ ., data = iris)\nsummary(tmp)\n\nundebug(lm) # turn debugging off\n```\n:::\n\n\n\n![The first thing I see when I run lm after turning on debug (screenshot)](../images/gen-prog/debug_init.png)\n\n![The variables passed into the lm function are available as named and used in the function. In addition, we have some handy buttons in the console window that will let us 'drive' through the function](../images/gen-prog/debug_console.png)\n\nAfter pressing \"next\" a few times, you can see that I've stepped through the first few lines of the lm function.\n\n![Stepping through the function. The arrow on the left side in the editor window shows which line of code we're currently at.](../images/gen-prog/debug_console2.png)\n\nWe can see that once we're at line 21, we get a warning about using type with a factor response, and that the warning occurs during a call to the `model.response` function. \nSo, we've narrowed our problem down - we passed in a numeric variable as the response (y) variable, but it's a factor, so our results aren't going to mean much. We were using the function wrong.\n\nWe probably could have gotten there from reading the error message carefully, but this has allowed us to figure out exactly what happened, where it happened, and why it happened. \n\n![I can hit \"Stop\" or type \"Q\" to exit the debug environment.](../images/gen-prog/debug_console_exit.png)\n\nBut, until I run `undebug(lm)`, every call to `lm` will take me into the debug window. \n\n:::\n\n`undebug(f)` will remove the debug flag on the function `f`. `debugonce(f)` will only debug f the first time it is run. \n\n\n::: callout-tip\n#### Try it out: `debug` in R\n\n::: panel-tabset\n\n##### Problem\n`larger(x, y)` is supposed to return the elementwise maximum of two vectors. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlarger <- function(x, y) { \n  y.is.bigger <- y > x \n  x[y.is.bigger] <- y[y.is.bigger] \n  x\n} \n\nlarger(c(1, 5, 10), c(2, 4, 11))\n## [1]  2  5 11\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlarger(c(1, 5, 10), 6)\n## [1]  6 NA 10\n```\n:::\n\n\nWhy is there an NA in the second example? It should be a 6. Figure out why this happens, then try to fix it. \n\n##### Solution\n\nI'll replicate \"debug\" in non-interactive mode by setting up an environment where x and y are defined\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nx <- c(1, 5, 10)\ny <- 6\n\n# Inside of larger() with x = c(1, 5, 10), y = 6\n(y.is.bigger <- y > x ) # putting something in () prints it out\n## [1]  TRUE  TRUE FALSE\ny[y.is.bigger] # This isn't quite what we were going for, but it's what's causing the issue\n## [1]  6 NA\nx[y.is.bigger] # What gets replaced\n## [1] 1 5\n\n\n# Better option\nlarger <- function(x, y) { \n  y.is.bigger <- y > x \n  ifelse(y.is.bigger, y, x)\n} \n```\n:::\n\n\n\n:::\n\n:::\n",
    "supporting": [
      "06-debugging_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}