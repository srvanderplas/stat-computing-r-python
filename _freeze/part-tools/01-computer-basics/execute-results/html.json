{
  "hash": "dc15ad3548eef1fe0ec93473f781b2e7",
  "result": {
    "engine": "knitr",
    "markdown": "# Computer Basics {#sec-computer-basics}\n\nBefore you learn how to program a computer, it can be helpful to learn a few basic things about how computers work.\nModern computing environments hide most of the details about where and how files are stored from the user, but when you write computer programs, these details suddenly become important.\n\n## Objectives {.unnumbered}\n\n-   Know the meaning of computer hardware and operating system terms such as hard drive, memory, CPU, OS/operating system, file system, directory, and system paths\n\n-   Understand the basics of how the above concepts relate to each other and contribute to how a computer works\n\n-   Understand the file system mental model for computers enough to identify where your files are stored\n\n-   Locate and follow directions for software installation based on your computer's hardware and operating system.\n\n::: diy\nIn this section, you will be identifying your computer's specifications.\n\nYou will want to have a notebook or text file that you can reference later to record this information.\nGo ahead and determine where you will save this information now.\n:::\n\n## Hardware\n\nThe components that make up the physical computer are the **hardware**.\nThis 3-minute video is focused on desktops, but the same components (with the exception of the optical drive) are commonly found in cell phones, smart watches, and laptops.\n\n::: youtube-video-container\n\n\n\n{{< video https://www.youtube.com/embed/Rdm8E59L8Og >}}\n\n\n\n\n\n:::\n\nThe important distinction for hardware is between Random Access Memoroy (RAM, or 'memory') and disk storage (hard drives).\nYou can usually store much more on disk than you can have available in RAM, but when working with \"big\" data[^01-computer-basics-1], we must use different approaches than when working with data that can fit in memory.\n\n[^01-computer-basics-1]: How big \"big\" is changes every couple of years -- it used to be several GB circa 2010, and now it's TB of data.\n\nWe also need to know at least a little bit about processors (so that we know when we've asked our processor to do too much).\nFor now, you are unlikely to challenge a modern processor when you first start learning R and Python, but as you acquire new skills, you may want to learn a bit about parallel processing (sending tasks to multiple processors).\nMost of the other details aren't critical to programming with data just yet -- graphics cards are important for some applications, but if you're just learning R and python, you have a ways to go before you get there.\n\n::: diy\nExamine the hardware on your computer using one of the following methods:\n\n-   Windows: Ctrl+Shift+Escape \\> Task Manager \\> More Options \\> Performance tab\n-   Mac: Apple menu \\> System Settings \\> General (sidebar) \\> About \\> System Report\n-   Linux: The `inxi` command will give you most of this on the command line, and `hwinfo --short` will give you a considerably more detailed printout.\n\nFind out:\n\n-   What processor do you have?\\\n    This most likely will start with ARM, Intel, AMD, or Apple M1\n\n-   How much RAM do you have?\n    (most likely between 8 and 64 GB)\n\n-   How much hard drive space do you have?\n\n-   What graphics device do you have?\n    (this might be slightly harder to find -- it's also less critical)\n:::\n\n::: learn-more\n-   [Chapter 1 of Python for Everybody](https://www.py4e.com/html3/01-intro) - Computer hardware architecture\n:::\n\n## Operating Systems\n\nOperating systems, such as Windows, MacOS, or Linux, are a sophisticated program that allows CPUs to keep track of multiple programs and tasks and execute them at the same time.\n\n::: youtube-video-container\n\n\n\n{{< video https://www.youtube.com/embed/RhHMgkUdhdk >}}\n\n\n\n\n\n:::\n\nChances are, you can't imagine doing computing without an operating system of some sort (and they've been ubiquitous on computers since the late 1980s).\nEven some appliances now have enough computing functions to require an operating system and an internet connection!\nTechnically, you can use some [Arduino and Raspberry Pi](https://electronics.stackexchange.com/questions/35247/raspberry-pi-without-os-on-it#35258) boards without an operating system[^01-computer-basics-2], but anything more complicated is almost guaranteed to have some minimal operating system available.\n\n[^01-computer-basics-2]: Chips and boards used without an operating system are often called \"embedded systems\".\n\nYou should be able to identify your operating system (OS for short) and follow instructions based on that information.\nYou will typically need to know not only the class of operating system (Windows/Mac/Linux) but also the version (e.g. Windows 11, Mac OSX Sierra, Debian 12, RedHat 7).\n\n::: diy\nLocate your operating system and version information.\nWhen was your system last updated?\n\nIf your system hasn't been updated in a while, consider updating it now -- system updates may break software you'll install to work with R and python packages in @sec-setting-up[^01-computer-basics-3].\n:::\n\n[^01-computer-basics-3]: If you are using an operating system that is older, know that some of the installation instructions may require modification (but there are likely others online who have attempted something similar, so you can usually Google for how to adjust things when they don't work).\n\n## File Systems\n\nFile systems are, unsurprisingly, places you save files.\nThey are modeled after physical file cabinets -- individual documents are kept in a hierarchical sequence of folders.\nUltimately, a collection of folders is stored on a **drive**.\n\nEvidently, there has been a bit of generational shift as computers have evolved: the \"file system\" metaphor itself is outdated because no one uses physical files anymore, and new apps don't show the user where on the computer their files are stored, forcing users to rely on the search feature instead of understanding file folders and paths.\n[Dan Robitzski provided an interesting discussion of the problem](https://futurism.com/the-byte/gen-z-kids-file-systems), making the argument that with modern search capabilities, most people use their computers as a laundry hamper instead of as a nice, organized closet and dresser (or file cabinet) [@robitzskiGenKidsApparently2021].\n\n::: youtube-video-container\n\n\n\n{{< video https://www.youtube.com/embed/KN8YgJnShPM >}}\n\n\n\n\n\n:::\n\nRegardless of how you tend to organize your personal files, it is probably helpful to understand the basics of what is meant by a computer **file system** -- a way to organize data stored on a hard drive.\nSince data is always stored as 0's and 1's, it's important to have some way to figure out what type of data is stored in a specific location, and how to interpret it.\n\n::: youtube-video-container\n\n\n\n{{< video https://www.youtube.com/embed/BV0-EPUYuQc >}}\n\n\n\n\n\n:::\n\n### Local and Network File Systems\n\nIt is important to distinguish between two primary types of file systems.\n\n-   **local file storage**: files are stored on a physical disk contained within the machine you are actively using.\n    A local file might be found at an address like `C:/Users/username/\\ Documents/unnamed.txt` or `/home/users/username/Documents/unnamed.txt` or `/Users/username/Documents/unnamed.txt`.\n\n-   **network file storage**, where files are stored \"in the cloud\" and you may have a link or a copy on your local machine.\\\n    Examples of network storage are Google Drive, Dropbox, Microsoft OneDrive, and iCloud.\n    Organizations may have privately-hosted network file storage, but these services are still dependent on access to the internet and thus fall under network file storage.\n\nIf you have used primarily mobile devices or Chromebook-style laptops, then you have likely dealt primarily with network storage.\nWhen programming, it is **essential** to know where your files are being stored.\nYou cannot conduct a file search to find your data and code (this is an interactive process).\nInstead, you will need to keep all of the files you need for a project together in a folder, and then keep track of where the project folder is stored.\n\nSome operating systems (Windows, Mac OS) prefer to save files in network storage services that may (or may not) be also stored on your physical hard drive.\nOver time, it has become harder to ensure that you are working on a local machine, but working \"in the cloud\" can cause odd errors when programming and in particular when working with version control systems[^01-computer-basics-5]\n\n[^01-computer-basics-5]: To disable OneDrive sync for certain windows folders, use [this guide](https://support.microsoft.com/en-us/office/files-save-to-onedrive-by-default-in-windows-10-33da0077-770c-4bda-b61e-8c8e8ca70ac7). \nOn Mac, see [\"Turn off Desktop and Documents\"](https://support.apple.com/en-us/109344) to stop iCloud sync of your Desktop and Documents folders (you can still manually copy things into iCloud for backup). \n\n\n### Allowed File Names\n\nDifferent operating systems (and file system formats) have different rules for how file names are handled within the file system.\n\n|   | Windows <i class=\"fa-brands fa-windows\"></i> | Mac OSX <i class=\"fa-brands fa-apple\"></i> | Linux <i class=\"fa-brands fa-linux\"></i> |\n|--------------|-------------------|--------------|--------------------------|\n| Disallowed Characters | `<`, `>`, `\"`, `/`, `\\`, `|`, `?`, `*` | `:`, some programs will restrict use of `/` . Avoid names that start with `.` unless the file should be hidden. | NULL character, `/` . Can't name files `.` or `..` . Avoid `\\`, `\"`, `'`, `*`, `;`, `?`, `[`, `]`, `(`, `)`, `~`, `!`, `$`, `<`, `>`, `#`, `@`, `&`, `|`, spaces, tabs, and newlines. Avoid names that start with `.` unless the file should be hidden. |\n| Case Sensitive | No. `A.jpg` is the same as `a.JPG` | [It's complicated](https://discussions.apple.com/thread/251191099?sortBy=rank). Act as if it's case sensitive to be safe. | Yes. `A.jpg` is different from `a.jpg` and `A.JPG` |\n| Name Length | Entire file path should be \\<256 characters[^01-computer-basics-4]. | (For HFS+ systems) File names \\< 255 characters. File paths can be longer. | File names \\< 255 characters, File paths \\< 4096 characters (most file system options, including ext4) |\n\n: File Naming Rules. All length limits assume UTF-8 characters -- limits may be shorter when using multibyte characters. \n\n[^01-computer-basics-4]: Longer paths [can be enabled via registry edits if you're brave/foolish](https://support.cs.jhu.edu/wiki/Windows_Path_Length_Limit_Reached).\n\n:::: example\n#### Example {-}\n\n::: panel-tabset\n##### Setup {-}\n\nA Windows user saves a picture as `my-pup.png` and references the picture in a file as `![Puppy picture](My-pup.PNG)`. \nThe picture link works fine when compiled on the Windows machine, but causes an error when the folder is copied to a Linux server and compiled. \n\nWhat do you think the error might look like? \n\nWhat went wrong?\n\nHow can the user ensure that the picture link works on every operating system?\n\n##### Answer {-}\n\nOn the Linux machine the user will get a file not found error. \n\n\nWindows is a case-insensitive operating system, so `my-pup.png` and `My-pup.PNG` will both point to the same file. \nThus, when referencing the picture `My-pup.PNG`, the system finds `my-pup.png` and concludes they are the same file. \n\nLinux is a case-sensitive operating system, which means that `my-pup.png` and `My-pup.PNG` point to different files. \nOn Linux, the file reference is to `My-pup.PNG`, and the only file in the directory is `my-pup.png`, which doesn't match the specified file name. \nThus, Linux will raise a **file not found** error because the file `My-pup.PNG` does not exist on the system. \n\n\nThe user should reference `my-pup.png` instead of `My-pup.PNG`. This file name will work across all major operating systems. \n\n:::\n::::\n\n\n\n### File Paths\n\n::: youtube-video-container\n\n\n\n{{< video https://www.youtube.com/embed/BMT3JUWmqYY >}}\n\n\n\n\n\n:::\n\nWhen you write a program, you may have to reference external files - data stored in `data.csv`, a diagram or picture, or a link to additional documentation.\n\nTo reference a file, you have to tell the computer where to look -- that is, you have to give it a **file path**. \nFile paths come in two basic types: \n\n- global file path: Starts at the file system location (e.g. `C:\\` or `/home` or `/Users`) and describes how to navigate to the file. \n\n- local file path: Starts at the program's current location (the **working directory**) and navigates to the file from that point. \n\nWhen you work on a project that may need to exist on some other machine, it's important to use **local** file paths -- the global path will likely not be the same, but you can usually set the local project-specific structure up to be the same across machines. \n\nIn fact, there's a very common shortcut that programmers take -- they set up a project-specific folder that is self contained. \nThat is, all of the data and code necessary for that project is provided within the folder. \nThen, the code within the folder can use local paths and will work when the project folder is copied to a new machine. \n\nTo help with organization, it's not uncommon to use a project structure like this:\n\n```\n- main-folder\n    - raw-data\n        - design.csv\n        - observations.csv\n        - other-vars.csv\n    - processed-data\n    - code\n        - 01-read-clean.xxx\n        - 02-analysis.xxx\n        - 03-simulation.xxx\n    - writeup.qmd\n    - README\n    - project-file.xxx\n```\n\nThe README file contains a basic overview of the project's contents. \nFiles are added to the `processed-data` subfolder after code is run. \nFiles in `raw-data` are set to read-only to prevent the data from being accidentally overwritten. \nA `project-file.xxx` file tells the program you're using (RStudio, VSCode, Positron, etc) what the specific settings are, and also that this directory should be treated as the **project root** -- that is, local file paths will start from this directory. \nWhen working on code, we will typically assume that the **working directory** (where the program looks for files) is `main-folder`.\n\n@picardiProjectOrganization2024 discusses several common layouts used for research projects.\n\n#### Using Paths to Navigate\n\nFile paths can be a bit tricky to construct, but there are a couple of shorthands that help a lot:\n\n- `.` represents the working directory\n- `..` is the directory that is above the working directory in the file system.\n- You enter a folder with `/` (Linux, Mac) or `\\` (Windows)    \n(in R, `\\` is an escape character. To represent a literal `\\`, you have to actually type `\\\\` is the directory separator)\n\nSo, the path `./dir1/dir2/my-project.Rproj` assumes the following file structure:\n\n```\n. - current directory\n    - dir1 \n        - dir2 \n            - my-project.Rproj\n```\n\nIt's a bit more challenging to think about paths that use the `..` shorthand. \nLet's think about a path like `../../../other-dir/other-data.csv`:\n\n```\n- my-dir\n    - dir1\n        - dir2\n            -my-project.Rproj\n- other-dir\n    - other-data.csv\n```\n\n::: {layout-ncol=2}\n\n![A local path from `my-dir` to `my-project.Rproj` needs to go through dir1 and dir2. ](../images/tools/file-path-demo-1.png){fig-alt=\"A directory structure with a folder 'example' containing my-dir and other-dir. my-dir contains dir1, which contains dir2, which contains my-project.Rproj. To navigate from my-dir to my-project.Rproj, we must go into dir1 and then go into dir2.\"}\n\n![A local path from `my-project.Rproj` to `other-data.csv` requires using the ../ to go to the parent folder. ](../images/tools/file-path-demo-2.png){fig-alt=\"A directory structure with a folder 'example' containing my-dir and other-dir. my-dir contains dir1, which contains dir2, which contains my-project.Rproj. To navigate from within dir2 to a file in other-dir, we must go up 3 directories and look in other-dir to find other-data.csv.\"}\n\n:::\n\n#### Constructing File Paths\n\nOn Windows, file paths are constructed as follows: `C:\\Folder 1\\Folder_2\\file.R`. Paths are *generally* not case sensitive, so you can reference the same file path as `c:\\folder 1\\folder_2\\file.R`. Usually, paths are encased in `\"\"` because spaces make interpreting file paths complicated and Windows paths have lots of spaces.\n\nOn Unix systems, file paths are constructed as follows: `/home/user/folder1/folder2/file.R`. Paths are case sensitive, so you cannot reach `/home/user/folder1/folder2/file.R` if you use `/home/user/folder1/folder2/file.r`. On Unix systems, spaces in file paths must be escaped with `\\`, so any space character in a terminal should be typed `\\ ` instead. \n\n\n::: callout\nIt's easier to just not use spaces in file paths, which you quickly find out when you've had to type paths into the terminal a few times, or if you ever use LaTeX [@xieDontUseSpaces2018].\n:::\n\nThis quickly gets complicated and annoying when working on code that is meant for multiple operating systems. These complexities are why when you're constructing a file path in R or python, you should use commands like `file.path(\"folder1\", \"folder2\", \"file.r\")` or `os.path.join(\"folder1\", \"folder2\", \"file.py\")`, so that your code will work on Windows, Mac, and Linux by default.\n\n## System Paths\n\nWhen you install software, it is saved in a specific location on your computer, like C:/Program Files/ on {{< fa brands windows >}}, /Applications/ on {{< fa brands apple >}}, or /usr/local/bin/ on {{< fa brands linux >}}.\nFor the most part, you don't need to keep track of where programs are installed, because the install process (usually) automatically creates icons on your desktop or in your start menu that point to the right location.\n\nUnfortunately, that isn't sufficient when you're programming, because you may need to know where a program is in order to reference that program -- for instance, if you need to pop open a browser window as part of your program, you're (most likely) going to have to tell your computer where that browser executable file lives.\n\nTo simplify this process, operating systems have what's known as a \"system path\" or \"user path\" - a list of folders containing important places to look for executable and other important files.\nYou may, at some point, have to edit your system path to add a new folder to it, making the executable files within that folder more easily available.\n\n::: callout-warning\n#### Error Messages That Indicate Path Problems {-}\n\nIf you run across an error like this:\n\n-   could not locate xxx.exe\n-   The system cannot find the path specified\n-   Command Not Found\n\nYou might start thinking about whether your system path is set correctly for what you're trying to do.\n:::\n\n:::: demo\n#### Demonstration: Path Errors {-}\n\nLet's see what path errors look like using different tools you might encounter.\n\n::: panel-tabset\n##### R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- read.csv(\"lego_sets.csv\") # Wrong Path\n## Error in file(file, \"rt\"): cannot open the connection\n\ntmp <- read.csv(\"../data/lego_sets.csv\") # Right Path\n```\n:::\n\n\n\n\n##### Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ntmp = pd.read_csv(\"lego_sets.csv\") # Wrong Path\n## FileNotFoundError: [Errno 2] No such file or directory: 'lego_sets.csv'\n\ntmp = pd.read_csv(\"../data/lego_sets.csv\") # Right Path\n```\n:::\n\n\n\n\n##### Bash\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nhead -n5 lego_sets.csv\n## head: cannot open 'lego_sets.csv' for reading: No such file or directory\n```\n:::\n\n\n\n:::\n::::\n\nIf you want to locate where an executable is found (in this example, we'll use `git`), you can run `where git` on windows, or `which git` on OSX/Linux.\n\nSome programs, like RStudio, have places where you can set the locations of common dependencies.\nIf you go to Tools \\> Global Options \\> Git/SVN, you can set the path to git.\n\n::: learnmore\n\n### Modifying Your System Path {-}\n\n[How to set system paths (general)](https://superuser.com/a/284361/391106)\n\nOperating-system specific instructions cobbled together from a variety of different sources:\n\n-   {{< fa brands windows >}} [On Windows](https://miktex.org/howto/modify-path)\n-   {{< fa brands apple >}} [On Mac](https://osxdaily.com/2014/08/14/add-new-path-to-path-command-line/)\n-   {{< fa brands linux >}} [On Linux](https://linuxize.com/post/how-to-add-directory-to-path-in-linux/)\n\n:::\n\n\n::: {.learnmore collapse=true}\n\n#### Shell Commands {-}\nCheck out @sec-basic-terminal for some basic shell commands in each operating system that will help you navigate your computer. \n\n:::\n## References {#part-tools-01-refs}\n",
    "supporting": [
      "01-computer-basics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}