{
  "hash": "a5cf211353e7fa07e371a0800b2ca1d9",
  "result": {
    "engine": "knitr",
    "markdown": "# Scripts and Notebooks and Terminals {#sec-scripts-notebooks}\nA better title for this chapter might be \"where to put code\" or \"how to talk to R and Python\". \n\n## Objectives {.nonumber}\n\n- Understand the different ways you can interact with a programming language\n- Identify which interface (terminal, interactive, script, notebook) and language are being used based on the appearance of the interface\n- Select the appropriate way of interacting with a computer for a given task given considerations such as target audience, human intervention, and need to repeat the analysis.\n\n## A Short History of Talking to Computers\n\nThe fundamental goal of this chapter is to learn how to talk to R and Python. \nBefore we get there, though, it's helpful to learn a bit about how we talk to computers more generally. \nThis will not only give you context for R and Python - it will also help you identify things that need to be done before you can complete a task.\n\n::: advanced\n### In the beginning...\n\nIn the very beginning, people told computers what to do using punch cards [@punched2023].\nActually, punch cards somewhat predate computers - they were used to tabulate census results long before modern machines that we would consider actual computers. \n\nPunch cards required that you have every step of your program and data planned out in advance - you'd submit your punch cards to the computer, and then come back 24-72 hours later to find out you'd gotten two cards out of order^[The `cards` command in SAS that precedes data input is a relic of this era. You can also use `datalines` now, but `cards` requires less typing so many people still use it.]. \nDropping a tray of punch cards was ... problematic.\n\n![Punch cards for a computer program. The red diagonal line on the top is a way to ensure the program is properly sorted. Image from [Wikimedia](https://commons.wikimedia.org/w/index.php?curid=16041053), By ArnoldReinhold - Own work, CC BY-SA 3.0, ]](../images/tools/punch-cards-wikimedia.jpg)\n\nThankfully, we're mostly free of the days where being a bit clumsy could erase a semester of hard work. \nAs things grew more evolved, engineers developed visual displays (monitors). \nThis enabled a new mode of interacting with computers: directly typing commands in, and receiving a response as soon as the task was completed. The primary way this interactivity happened, at least at first, was using interfaces called terminals or command prompts. \n\n:::\n\n### Terminals\n\nA **terminal** is a text interface where you give instructions to a computer that tell the computer what to do. \nA **command prompt** is another, similar, term (often used interchangeably) which refers to the character used to indicate that the computer is waiting for a command. \nOn different systems, this character might be `>>>`, `>`, `$`, `%`, or something you can customize yourself.\nMost systems allow you to tinker with the configuration of the terminal - what is shown on your machine may not be similar to what is shown in the images below, but the goal of looking at multiple prompts is to help you recognize the common components across operating systems enough to make sense of your machine.\n\n\n::: aside\nWhen I first learned how to use a computer, circa 1992, terminal interfaces (DOS) were the primary way you used a computer. \nMy parents set up a custom menu that would allow me to launch computer games by typing different numbers.\nWindows 3.1 was an absolute revelation -- we had to buy a mouse, and you could actually move things around a screen! And the screen had more than 4 colors ðŸŒˆ!\n:::\n\n\nMost modern computer users don't engage with terminal interfaces very often (or at all). \nAs you learn to program, you will become more comfortable with the terminal for completing basic tasks like moving files around, running programs, and obtaining diagnostic information. \nUsually, you pick up this information over time and when you're frustrated trying to do a task some other way. \n\nFor now, it's enough to know what a terminal is and to recognize it when you see it. \n\nLet's look at a terminal window for each operating system for a minute and examine the important parts. \n\n::: panel-tabset\n\n#### {{< fa brands windows >}} Windows \n\nThe default terminal on Windows is `cmd.exe`. \n\n![Windows terminal. The location on the computer is shown first, and the prompt character is `>`.](../images/tools/windows-terminal.png)\n\nMany people dislike `cmd.exe` and prefer to install PowerShell, which is a more fully featured terminal program. \n![A PowerShell window generally shows your location; in this configuration, the prompt character is '>'. Note that powershell has a PS at the beginning of the line, alerting the user that they are not in `cmd.exe`. ](../images/tools/powershell-terminal.png)\n\n#### {{< fa brands apple >}} Mac \n\n![In a Mac terminal, you can see the username, computer name, location, and prompt character '%'. (base) in this image is printed because this user has a conda environment loaded -- this is something that may happen depending on how you install python. Macs use Zsh, which is a command line program (Z-shell) that interprets user input. ](../images/tools/mac-terminal.png)\n\n#### {{< fa brands linux >}} Linux \n\n![This is an example of a KDE-based terminal on Linux. The Username, computer name, location, and prompt character '$' are all present. This linux terminal uses BASH, which is a slightly different command line program than the Z-shell used on Macs. In Linux, it is common to choose the terminal program you most prefer, and there are many options.](../images/tools/linux-terminal.png)\n\n:::\n\nSystem terminals have their own languages, and they're not consistent across operating systems. \nBy default, terminals come with a set of commands described as {{< fa brands windows >}} Batch (Windows), {{< fa brands apple >}} Zsh (Mac), or {{< fa brands linux >}} Bash (default in most Linux systems).\n\nThe most important things to know how to do in a system terminal are:\n\n1. Launch a program like python or R\n\n2. Change your location/working directory (`dir <path\\to\\folder>` on Windows, `cd <path/to/folder>` on Linux/Mac)\n\nThere are lots of other things you *can* do, but those are the two big ones. \n\nLet's try launching R and python from a system terminal, and then see that we can get the same windows within RStudio. \nKeeping all of the windows you need for programming in one place is one of the most important features of an **integrated development environment (IDE)** like RStudio. \n\n::: diy\n### Try it out! Interactive Command Prompts in R and Python\n\n::: panel-tabset\n\n#### R - System Terminal\n\nOpen your system terminal and type `R`. Hit enter.  You can issue commands directly to R by typing something in at the `>` prompt.\n\n\nTry typing in `2+2` and hit enter.\n\n![Launching R from the system terminal](../images/tools/terminal-launch-r.gif)\n\n\n#### Python - System Terminal\n\nOpen your system terminal and type `python` (on some systems, like mine, you may have to type `python3` instead). Hit enter.  You can issue commands directly to python by typing something in at the `>>>` prompt.\n\n\nTry typing in `2+2` and hit enter.\n\n![Launching python from the system terminal](../images/tools/terminal-launch-py.gif)\n\n#### RStudio - R\n\nOpen RStudio and navigate to the Console tab. You can issue commands directly to R by typing something in at the `>` prompt.\n\nTry typing in `2+2` and hit enter.\n\n![The Console tab is the left-most tab in RStudio - you can see that R's welcome message shows up first, along with version information. The last component visible is the `>`, which indicates that R is waiting for you to tell it to do something. Hitting enter will submit the command to calculate 2+2. Hopefully, you get 4.](../images/tools/Rstudio-r-console.png)\n\n#### RStudio - Python\n\nOpen RStudio and navigate to the Terminal tab. This is a \"system terminal\" - that is, where you tell the computer what to do.\n\nWe tell the computer we want to work in python by typing in `python3` or `python` (depending on how your computer is set up). \nThis will launch an interactive python session (**ipython**).\n\nYou should get a prompt that looks like this: `>>>`\n\n![Bash terminal window (on Linux - yours will look different). The first line shows the default prompt, and I typed in `python` and hit enter, launching the `python` program. The remaining lines are the Ipython startup messages showing the version of python and the operating system. The `>>>` prompt indicates that python is waiting for a command. Hitting enter will cause Python to calculate the result of 2+2.](../images/tools/rstudio-launch-py.gif){fig-alt=\"A bash Linux terminal within RStudio. The first line shows the user, computer name, and path, along with some extra stuff in parentheses at the beginning that doesn't matter now. The `$` character indicates that bash is waiting for a command: `python`. The next two lines are the python startup messages indicating the python version and operating system, and suggesting relevant commands like help, copyright, credits, and license for more information. Finally, there is a >>> prompt at which the user has typed 2+2.\"}\nType in `2+2` and hit enter.\n\n:::\n:::\n\nUsing the console interactively can be useful for quick things, like performing a simple arithmetic calculation, but imagine doing a complicated analysis that requires typing in 10, 15, or 20 commands!\nYou'd have to re-type the same commands any time you wanted to bring up the results, which very quickly gets tedious. \n\n\n### Scripts\n\nAt one point, I wanted to keep a record of the temperature around my house so that I could examine how my heating bill changed with the temperature and determine if an upgrade to a heat pump was cost effective. \nI decided to record the outside temperature every 6 hours, writing that information to a file along with the date and time. \nThis only required a few commands, but I wasn't willing to commit to being at the computer every 6 hours for the rest of my life, and I wanted the data to be complete.\n\n\nEnter scripts.\n\nIf you need to repeat the same analysis, or even just remember what commands you used, typing each command in each time is not ideal. \nA **script** is a text file which records a series of commands so that they can be run together.\n\n\nInteractive mode is useful for quick, one-off analyses, but if you need to repeat an analysis (or remember what you did), interactive mode is just awful. \nOnce you close the program, the commands (and results) are gone. \nThis is particularly inconvenient when you need to run the same task multiple times. \n\nTo somewhat address this issue, most computing languages allow you to provide a sequence of commands in a text file, or a script.\nIn many languages, scripts are intended to run on their own, from start to finish. \nWe often call this **executing** a script, and this is typically done from a terminal prompt. \n\n\n::: diy\n#### Try it out! Scripts and Terminals\n\nLet's take a minute and see how someone might **call** or **run** a script from the terminal. \n\n1. Download [scripts.zip](../files/scripts.zip) and unzip the file.\n\n2. Open a system terminal in the directory where you unzipped the files.    \nFollow the directions below *exactly* to ensure that you have the terminal open in the correct location.\n\n::: panel-tabset\n\n##### {{< fa brands windows >}} Windows \n\nOpen the folder. Type cmd into the location bar at the top of the window and hit enter. The command prompt will open in the desired location.\n\n##### {{< fa brands apple >}} Mac \n\nOpen a finder window and navigate to the folder you want to use. If you don't have a path bar at the bottom of the finder window, choose View \\> Show Path Bar. Control-click the folder in the path bar and choose Open in Terminal.\n\n##### {{< fa brands linux >}} Linux \n\nOpen the folder in your file browser. Select the path to the folder in the path bar and copy it to the clipboard. Launch a terminal and type `cd`, and then paste the copied path. Hit enter. (There may be more efficient ways to do this, but these instructions work for most window managers).\n\n:::\n\n\n3. Now, let's try out running a script from the terminal in R and Python!\n\n::: panel-tabset\n\n#### R {-}\n\nThis assumes that the R binary has been added to your system path. \nIf these instructions don't work, please ask for help or visit office hours.\n\nIn the terminal, type `Rscript words.R dickens-oliver-twist.txt`\n\nYou should get some output that looks like this:\n\n    user@computer:~/scripts$ Rscript words.R dickens-oliver-twist.txt \n    text\n     the  and        to   of    a  his   in   he  was \n    8854 4902 4558 3767 3763 3569 2272 2224 1931 1684\n\n#### Python  {-}\n\nThis assumes that the python binary has been added to your system path. If these instructions don't work, please ask for help or visit office hours.\n\nIn the terminal, type `python3 words.py` and hit Enter. You will be prompted for the file name. Enter `dickens-oliver-twist.txt` and hit Enter again.\n\nYou should get some output that looks like this:\n\n    user@computer:~/scripts$ python3 words.py \n    Enter file:dickens-oliver-twist.txt\n    the 8854\n:::\n:::\n\n\n::: callout-note\nFor more information about how to use system terminals, see @sec-shell-commands. \n:::\n\n\nScripts, and compiled programs generated from scripts, are responsible for much of what you interact with on a computer or cell phone day-to-day. \nWhen the goal is to process a file or complete a task in exactly the same way each time, a script is the right choice for the job.\n\n#### Using Scripts Interactively\n\nScripts are also used interactively in some languages, like R and python, when doing data analysis. \nBecause data analysis depends on the data, and data isn't ever exactly the same or 100% what you expect it to be, people programming with data often use scripts and run the code in the script interactively.\nAbout 70% of my day-to-day computing is done using R or python scripts that are run interactively.\n\n\nWhen a script is ready for \"production\" - that is, ready to be used without interactive human supervision, data scientists may use it that way.  \nBut many data scientists and statisticians never move beyond using scripts interactively -- and that is ok!\n\nWhen you look for help online, though, it's important to be able to distinguish between help that assumes you're **calling** or **executing** a script (running it from the command line) and help that assumes you're working with a script and using it interactively. \n\n\n#### Sourcing Scripts\n\nTo make this even more confusing, it's possible to run an entire script, or a chunk of a script, within RStudio. \nWhen we talk about running an entire script file within RStudio, we will often say we're **sourcing** the file. \nThis is because in R, to include a file of commands within another script, you run the command `source(\"path/to/file.R\")`. \n\nThe difference between sourcing, running, and executing a script is fairly nuanced and the vocabulary is often used interchangeably, which doesn't help you as you're learning!\n\n::: diy\n#### Try it out! Sourcing a Script\n\nIf you haven't already, download [scripts.zip](../files/scripts.zip) and unzip the file.\n\nOpen RStudio and use RStudio to complete the following tasks.\n\n::: panel-tabset\n##### R\n\n1.  Use RStudio to open the `words-noinput.R` file in the `scripts` folder you downloaded and unzipped.\n\n2.  What do you notice about the appearance of the file? Is there an icon in the tab to tell you what type of file it is? Are some words in the file highlighted?\n\n3.  Copy the path to the scripts folder.    \n    OS Specific Instructions: [{{< fa brands windows >}} Windows](https://www.laptopmag.com/articles/show-full-folder-path-file-explorer), [{{< fa brands apple >}} Mac](https://support.apple.com/guide/mac-help/get-file-folder-and-disk-information-on-mac-mchlp1774/mac), [{{< fa brands linux >}} Linux](https://askubuntu.com/questions/23413/how-can-you-quickly-get-the-complete-path-to-a-file-for-use-in-terminal)\n\n4.  In the **R Console**, type in `setwd(\"<paste path here>\")`, where you paste your file path from step 3 between the quotes. Hit enter.\n\n5.  In the `words-noinput.R` file, hit the \"source\" button in the top right. Do you get the same output that you got from running the file as a script from the terminal? Why do you think that is?\n\n6.  Click on the last line of the file and hit Run (or Ctrl/Cmd + Enter). Do you get the output now?\n\n7.  Click on the first line of the file and hit Run (or Ctrl/Cmd + Enter). This runs a single line of the file. Use this to run each line of the file in turn. What could you learn from doing this?\n\n##### Python\n\n1.  Use RStudio or your preferred python editor to open the `words-noinput.py` file in the `scripts` folder you downloaded and unzipped.\n\n2.  What do you notice about the appearance of the file? Is there an icon in the tab to tell you what type of file it is? Are some words in the file highlighted?\n\n3.  Copy the path to the scripts folder.    \n    OS Specific Instructions: [{{< fa brands windows >}} Windows](https://www.laptopmag.com/articles/show-full-folder-path-file-explorer), [{{< fa brands apple >}} Mac](https://support.apple.com/guide/mac-help/get-file-folder-and-disk-information-on-mac-mchlp1774/mac), [{{< fa brands linux >}} Linux](https://askubuntu.com/questions/23413/how-can-you-quickly-get-the-complete-path-to-a-file-for-use-in-terminal)\n\n4.  In the **R Console**, type in `setwd(\"<paste path here>\")`, where you paste your file path from step 3 between the quotes. Hit enter.\n\n5.  In the `words-noinput.py` file, hit the \"source\" button in the top right. Do you get the same output that you got from running the file as a script from the terminal? What changes?\n\n6.  Click on the first line of the file and hit Run (or Ctrl/Cmd + Enter). This runs a single line of the file. Use this to run each line of the file in turn. What do you learn from doing this?\n\n:::\n:::\n\nUsing scripts interactively allows us to see what is happening in the code step-by-step, and to examine the results during the program's evaluation. \nThis can be beneficial when applying a script to a new dataset, because it allows us to change things on the fly while still keeping the same basic order of operations.\n\nYou can run single lines of code within a script file by clicking on the line and using the \"Run\" button in RStudio, or by typing Ctrl/Cmd + Enter, which will run the selected line(s) of code in the Console. \n\n## Writing Code for People\n\nOne problem with scripts and interactive modes of using programming languages is that we're spending most of our time writing code for computers to read -- which doesn't necessarily imply that our code is easy for **humans** to read.\nAs you become more proficient at programming, you will realize quickly that writing readable code is more challenging than writing working code. \nIt is hard to remember what a specific block of code did when you come back to it months after you wrote it!\n\nThere are two solutions to this problem, and I encourage you to make liberal use of both of them (together).\n\n### Code Comments\n\nA **comment** is a part of computer code which is intended only for people to read. It is not evaluated or run by the computing language.\n\nTo \"comment out\" a single line of code in R or python, put a `#` (pound sign/hashtag) just before the part of the code you do not want to be evaluated.\nThis works in both R and Python. \nOther languages also have so-called **inline** comments, but may use a different character to indicate that something is a comment. \n`// Comment text` and `<!-- Comment text -->` are in-line comments for JavaScript and HTML, respectively. \n\n::: callout-demo\n\n#### Adding Comments to Code\n\n::: panel-tabset\n##### R {-}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 2 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\n2 + 2 # + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# This line is entirely commented out\n```\n:::\n\n\n\n\n##### Python {-}\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n2 + 2 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n7\n```\n\n\n:::\n\n```{.python .cell-code}\n2 + 2 # + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4\n```\n\n\n:::\n\n```{.python .cell-code}\n# This line is entirely commented out\n```\n:::\n\n\n\n\n:::\n:::\n\nMany computing languages, such as Java, C/C++, and JavaScript have mechanisms to comment out an entire paragraph. \n\nNeither R nor Python has so-called \"block comments\" - instead, you can use keyboard shortcuts in RStudio to comment out an entire chunk of code (or text) using Ctrl/Cmd-Shift-C.\n\n### Literate Programming - Notebooks and more!\n\nWhile code comments add human-readable text to code, scripts with comments are still primarily formatted for the computer's convenience.\nHowever, most of the time spent on any given document is spent by people, not by computers. \nSome groups write parallel documents - code, user manuals, internal wikis, tutorials, etc. which explain the purpose of code and how to use it, but this can get clumsy over time, and requires updating multiple documents (sometimes in multiple places), which can lead to the documentation getting out-of-sync from the code.\n\nTo solve this problem, Donald Knuth invented the concept of **literate programming**: interspersing text and code in the *same document* using structured text to indicate which lines are code and which lines are intended for human consumption.\n\nThis textbook is written using a literate format - quarto markdown - which allows me to include code chunks in R, python, and other languages, alongside the text, pictures, and other formatting necessary to create a textbook.\n\nOne major side effect of literate programming is that it is easy to include the results of a block of code inside the primary document. \nThis means that you can generate plots, tables, and other information using code, and include them into a document, without having to copy and paste or insert figures within the text. \nWhile this advantage may not seem worth it to you at this point, once you have a ton of plots in a document and the data changes just slightly, the advantage becomes crystal clear. \n\nWriting documents using literate programming saved me so much time in as an industry data scientist that I really only had about 8 hours of work in a week - I'd automated the rest away by building re-usable reports that updated when new data arrived. \n\n#### Quarto\n\nOne type of literate programming document is a **quarto markdown** document.\n\nWe will use quarto markdown documents for most of the components of this class because they allow you to answer assignment questions, write reports with figures and tables generated from data, and provide code all in the same file.\n\nWhile literate documents aren't ideal for jobs where a computer is doing things unobserved (such as pulling data from a web page every hour), they are extremely useful in situations where it is desireable to have both code and an explanation of what the code is doing and what the results of that code are in the same document.\n\n::: diy\n\n####  Try It Out! Words in quarto\n\n\nIn the `scripts.zip` file you downloaded earlier, there is a `words.qmd` file as well as a `words.html` file. \n\nOpen `words.html` in your browser, and open `words.qmd` in RStudio. `words.html` was generated from `words.qmd`. \n\n- Read through `words.html` and find the corresponding sections of `words.qmd`. \n\n![Quarto text (left) and rendered HTML (right)](../images/tools/Rstudio-words-quarto.png)\n\n- In RStudio, click the \"Render\" button. The HTML file should appear at the bottom left in the \"Viewer\" tab. \n\n![The render button is located at the top of the text editor/script pane (usually, the top left panel).](https://quarto.org/docs/get-started/hello/images/rstudio-render.png)\n\nCongratulations, you've just compiled your first Quarto document!\n\n:::\n\n\n::: diy\n\n#### Try It Out!  Quarto Markdown\n\nIn RStudio, create a new quarto markdown document: File \\> New File \\> Quarto Document. Give your document a title and an author, and select HTML as the output.\n\nCopy the following text into your document and hit the \"Render\" button at the top of the file.\n\n    This defines an R code chunk. The results will be included in the compiled HTML file.\n\n    ```{{r}}\n    2 + 2 \n    ```\n\n    This defines a python code chunk. The results will be included in the compiled HTML file.\n\n    ```{{python}}\n    2 + 2\n    ```\n\n    # This is a header\n\n    ## This is a subheader\n\n    I can add paragraphs of text, as well as other structured text such as lists:\n\n    1. First thing\n    2. Second thing\n      - nested list\n      - nested list item 2\n    3. Third thing\n\n    I can even include images and [links](https://www.oldest.org/entertainment/memes/)\n\n    ![Godwin's law is almost as old as the internet itself.](https://www.oldest.org/wp-content/uploads/2017/10/Godwins-Law.jpg)\n:::\n\nMarkdown is a format designed to be readable and to allow document creators to focus on content rather than style.\n\n> A Markdown-formatted document should be publishable as-is, as plain text, without looking like it's been marked up with tags or formatting instructions. -- John Gruber\n\nYou can read more about pandoc markdown (and quarto markdown, which is a specific type of pandoc markdown) [here](https://quarto.org/docs/authoring/markdown-basics.html) [@positpbcQuartoMarkdownBasics2023].\n\nMarkdown documents are **compiled** into their final form (usually, HTML, PDF, Docx) in multiple stages: \n\n1. All code chunks are run and the results are saved and inserted into the markdown document.   \nRmd/qmd -\\> md\n\n2.  The markdown document is converted into its final format using **pandoc**, a program that is designed to ensure you can generate almost any document format. This may involve conversion to an intermediate file (e.g. .tex files for PDF documents).\n\nAn error in your code will likely cause a failure at stage 1 of the process. An error in the formatting of your document, or missing pictures, and miscellaneous other problems may cause errors in stage 2.\n\n::: {.callout-note icon=\"fa-timeline\"}\n##### History\n\nQuarto markdown is the newest version of a long history of literate document writing in R. A previous version, Rmarkdown, had to be compiled using R; quarto can be compiled using R or python or the terminal directly.\n\nPrior to Rmarkdown, the R community used `knitr` and `Sweave` to integrate R code with LaTeX documents (another type of markup document that has a steep learning curve and is harder to read).\n:::\n\n#### Jupyter\n\nWhere quarto comes primarily out of the R community and those who are agnostic whether R or Python is preferable for data science related computing, Jupyter is an essentially equivalent notebook that comes from the python side of the world.\n\nQuarto supports using the jupyter engine for chunk compilation, but jupyter notebooks have some (rather technical) features that make them less desirable for an introductory computing class [@xieFirstNotebookWar2018].\nAs a result, this book makes an opinionated decision to prefer quarto over jupyter. \n\n::: learnmore\n#### Learn More about Notebooks\n\nThere are some excellent opinions surrounding the use of notebooks in data analysis:\n\n-   [Why I Don't Like Notebooks\"](https://docs.google.com/presentation/d/1n2RlMdmv1p25Xy5thJUhkKGvjtV-dkAIsUXP-AL4ffI/preview#slide=id.g362da58057_0_1) by Joel Grus at JupyterCon 2018\n-   [The First Notebook War](https://yihui.org/en/2018/09/notebook-war/) by Yihui Xie (response to Joel's talk).\n\nYihui Xie is the person responsible for `knitr` and `Rmarkdown` and was involved in the development of `quarto`.\n:::\n\n## References {#part-tools-03-refs}\n",
    "supporting": [
      "04-scripts-notebooks_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}