# Working with PDFs {#sec-pdf-data}

When I started my first job out of graduate school, one particular process used by my coworkers completely mystified me: they would print out a document, and then immediately scan it back in, with the scan emailed to themselves.
This seemed like a waste of toner, paper, and time to me -- why would anyone do such a thing?
Eventually, I found out that the printer would automatically recognize the text and add a text layer to a PDF that previously couldn't be highlighted. 
So, my coworkers found a handy workaround to manually typing out the numbers they needed from older PDF documents!
As clever as this was, it was also unnecessary. A lot of paper, toner, and time could have been saved if the company had just provided **Optical Character Recognition** programs and made them available to workers. 

In this chapter, you'll learn about PDF document structure, as well as how to use OCR programs.

::: column-margin

![DOWNSIDES: Adobe people may periodically email your newsroom to ask you to call it an 'Adobe® PDF document,' but they'll reverse course once they learn how sarcastically you can pronounce the registered trademark symbol.<br>CC-A-NC2.5 by Randall Munroe. [source](https://xkcd.com/2304/)](../images/advanced/xkcd-2304-preprint.png){fig-alt='The image is a comic strip depicting a person sitting at a news desk. The person has simplistic features with a round head, short hair, and no facial features drawn. A speech bubble above them says "According to a new PDF..." Behind them is a sign reading "Breaking News." Crossed out phrases above them include "According to a new preprint...", "...an unpublished study...", and "According to a new paper uploaded to a preprint server, but which has not undergone peer review...". Below the main image, there\'s a section titled "Benefits of just saying \'a PDF\':" followed by three bullet points. • AVOIDS IMPLICATIONS ABOUT PUBLICATION STATUS • IMMEDIATELY RAISES QUESTIONS ABOUT AUTHOR(S) • STILL IMPLIES "THIS DOCUMENT WAS PROBABLY PREPARED BY A PROFESSIONAL, BECAUSE NO NORMAL HUMAN TRYING TO COMMUNICATE IN 2020 WOULD CHOOSE THIS RIDICULOUS FORMAT".'}

:::

## Objectives {-}

- Identify the type of PDF and the data it contains.
- Develop a strategy to extract the data from the PDF programmatically, using strategies to improve the success of Optical Character Recognition (OCR) if necessary.
- Augment the PDF files with OCR to add a text layer, if necessary, before extracting information.
- Extract information from PDFs programmatically and format the information appropriately.
- Implement quality control and data cleaning measures which handle the most common OCR errors elegantly. 

## Introduction

Over the objections of open data organizations, data archivists [@klindtPDFConsideredHarmful2017], and programmers [@edwardsWhyExtractingData2025;@zhangDocumentParsingUnveiled2024], companies and government agencies frequently use PDF (portable document format) documents to store and release data.
Election results ([Oregon, 2024](https://sos.oregon.gov/elections/Documents/results/november-general-2024-results.pdf)), property appraisals ([Lancaster County, Nebraska](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28719-2025-147568.pdf)), public health reports ([Centers for Disease Control Morbidity and Mortality Weekly Reports](../data/cdc-mmwr-2025-07-10.pdf)), and more, locked up [@harbertTappingPowerUnstructured2021] in PDF format instead of stored properly in nicely formatted spreadsheets or databases. 
Even though we object to the storage mechanism, learning how to deal with data stored in PDF format is a valuable skill for the aspiring data scientist. 
Even if you never work with PDF data in a professional capacity (and I hope you're that lucky), these skills are very useful for public data side projects. 

### PDF File Format

The PDF file format was created in 1993 by Adobe and was a proprietary format until 2008, when the format became an open standard under the control of the International Standards Organization [@wikimediacontributorsHistoryPDF2024]. 
As the acronym suggests, Portable Document Format is intended to be readable on any computer. 
This was something of a novel idea in the 1990s, when Mac users used one document creation software and Windows users another, and there was not a version of e.g. Microsoft Office available for Mac.

The technical details of a PDF file are complex [@gnupdfprojectIntroductionPDF2014;@hodsonPDFSuccinctly2012].
However, conceptually, there are four required components to a PDF document, as shown in @fig-pdf-doc-components: 

::: column-margin
![High-level required components of a PDF document.](../images/advanced/pdf-document-components.png){#fig-pdf-doc-components fig-alt="A box containing four colored boxes: Header, Body, Cross-ref table, and Trailer." .lightbox}

![Required components of a PDF Body](../images/advanced/pdf-body-components.png){#fig-pdf-body-components fig-alt="A network diagram showing the Catalog, with an arrow leading to the Page Tree. Below the Page tree are two page nodes, Page 1 and Page 2. Arrows connect the Page tree to the pages, and the pages to the page tree. The final layer of the network contains page 1 content, resources, and page 2 content. Arrows point from page 1 and 2 to the resources node, as well as to the corresponding page content." .lightbox}
:::

- Header
    - PDF version number
    - arbitrary sequence of binary data to prevent applications from opening the document as a text file (which would corrupt the file)
- Body (relationships between body components shown in @fig-pdf-body-components)
    - Page tree - serves as the root of the document, and may be as simple as a list of pages.
    - Pages - each page is defined independently and contains its own metadata, links to resources, and content (defined separately). 
    - Resources - objects required to render a page, such as fonts.
    - Content - text and graphics which appear visually on the page. 
    - Catalog - an indication to programs as to where to start reading the document. Often this is just a link to the root page tree.
- Cross-reference table - Records the location in the file of each object in the body of the file so that when viewing a page, only objects from that page are loaded into memory. 
- Trailer - tells applications how to read the file
    - A reference to the catalog which links to the document root
    - Location of the cross-reference table
    - Size of the cross-reference table

@kingAdobeIntroductionInsides2005 has some good examples showing pages and the PDF document code that create the pages. 

Within the page, **streams** are often used to define the page's appearance (the other option is **lattices**, which can be used to divide the page up into sections). 
To add text, commands are issued to define the font, position the text cursor, and type the text onto the page. 
Text is positioned from the bottom left corner, with $Y$ defining the vertical and $X$ defining the horizontal location. 
Line breaks and other formatting features are not a part of the PDF format -- these operations are performed by another program before the file is saved as PDF. 
As a result, text commands in PDF can be fragmented, leading to a continuous paragraph of words being written in the PDF file as separate lines, with other page elements present in between (like figure captions, page numbers, and images). 
In addition, PDF documents allow for changing the kerning of text (space between letters) in specific ways that may make it difficult for the characters to be separated visually. 
One common example of this is the sequence of characters `ff` or `fi` in a document, which can sometimes be read in interesting ways by OCR: sometimes, as unicode ﬀ or ﬁ, sometimes as Cyrillic characters, and sometimes left out entirely or misplaced. 



::: demo

### Demo: Hybrid PDF Fun {-}

Consider a [Home appraisal record from Lancaster County, NE](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28719-2025-147568.pdf). 
Opening the card in a PDF reader and selecting all the text yields a [disorganized text file](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28719-2025-147568.txt) (and this PDF is actually created using modern methods and relatively clean!)

A few observations, marked up in @fig-pdf-layout-text: 

- The title on page 1 is on line 39 of the file, and it appears that the data from the first column is on lines 1-38. 
- When there are multi-column tables, as in the "Inspection History" table in the middle of the first page, the values are listed by column, but missing values (the times of inspection) are not indicated at all!
- The Appraised Values table has columns Land, Building, Total, and Method. Line 142 of the text file shows an entry for "Total Method", and it is clear that the text for the two columns has been combined. 

![Comparing text of PDF document to the rendered PDF document.](../images/advanced/Lancaster-County-NE-Real-Estate-AppraisalCard-28719-2025-147568.svg){#fig-pdf-layout-text .lightbox fig-alt="A screenshot of the first page of the PDF, with boxes highlighting the locations corresponding to the points shown above. In the Appraised Values table, arrows are shown connecting the Appraised Values header, Land, Building, Total Method, Current, $45,000, $111,000, $156,000 IDXVAL, Prior, $45,000, $111,000, and $156,000 IDXVAL sequentially."}

Now, perhaps we could write a script that would disentangle some of this information and format it properly, though I think the missing values would still be unrecoverable without someone visually mapping the data to the corresponding lines. 

The arrangement of the text you get from selecting all text is different in different PDF applications -- I tried it with [Okular](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568.txt) and [Firefox](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-Firefox.txt), and got totally different orders of text boxes. 

The scope of the actual problem only becomes visible when you look at a second [PDF document](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568.pdf) and the corresponding [text file](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568.txt). 
@fig-pdf-layout-text-parallel shows the two PDF files and their corresponding text files, with the comparable portion of each PDF and text file highlighted. 

![Lancaster county, NE real estate appraisal cards and text, with correpsonding sections highlighted across two appraisal cards. The text corresponding to the same space on the PDF has different formatting because one row of the table is blank on one of the cards.](../images/advanced/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568.png){#fig-pdf-layout-text-parallel .lightbox fig-alt="A screenshot of the text files and PDF files for both real estate appraisal cards. The recent appeal history and assessed value history table headers and first row of text are highlighted in both sets of documents."}


:::

Hopefully you're beginning to understand how challenging this whole extracting data from PDFs thing can be!

### PDF Layers

Practically, we can think of PDFs as having a text layer, an image layer, or both (hybrid PDFs). 
A PDF with a text layer will allow you to select embedded text and copy it into a text file, while a PDF that just has an image layer does not. 
It is also possible to have a PDF that has an image layer with a corresponding text layer on top. 
Optical Character Recognition takes a PDF with only image layers and creates a text file (or layer, depending on the tool) by  identifying the characters in the document and converting those characters to text with a corresponding $(x,y)$ location in the document.
Different OCR programs use different conventions for this process, and the quality of the image matters a lot as well - some images are just not good enough to produce a passable transcription of the text using automatic methods. 

:::: demo

### Demo: Types of PDF Files and Layers {-}

For this demo, I've converted the first page of one of the Lancaster county, NE property appraisal PDFs into an [image only PDF](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-image.pdf) and a [text-based PDF (the original form)](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-text.pdf). 
Open these up in your favorite PDF editor and try to highlight the text in each. How does it work?

We can also examine the format of a PDF file using R and python libraries. 

::: panel-tabset

#### R {-}
You'll need the `pdftools` package, which you can install with `install.packages("pdftools")`. 
This may require you to install `libpoppler` on Linux <i class="fa-brands fa-linux" aria-hidden="true"></i>, but versions for other operating systems should be self-contained. 

The `pdf_info` function gives us information from the PDF header, and the `pdf_text` function tries to extract the text, if it exists. 

```{r}
library(pdftools)

pdf_info("../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-text.pdf")$version
pdf_text("../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-text.pdf") |>
  str_split("\n") |>
  unlist() |>
  head()


pdf_info("../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-image.pdf")$version
pdf_text("../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-image.pdf") 
```

Notice that the text does not exist for the image-based PDF. 

#### Python {-}

You will need the `pdfplumber` package [@singer-vinePdfplumber2025], which you can install with pip. 

The `pdf` object contains `metadata` and `pages`, and page text (if it exists) can be accessed with the `pdf.pages[i].extract_text()` method.

```{python}
import pdfplumber
with pdfplumber.open("../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-text.pdf") as pdf:
  metadata = pdf.metadata
  first_page =  pdf.pages[0]
  text = first_page.extract_text()

pdf.close()
metadata
text.split("\n")[0:5]

with pdfplumber.open("../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-image.pdf") as pdf:
  metadata = pdf.metadata
  first_page =  pdf.pages[0]
  text = first_page.extract_text()

pdf.close()
metadata
text.split("\n")[0:5]
```

:::

Now, I created the image version of the PDF by opening the PDF in an image editor and saving the resulting file as PDF within that image editor, so it's not surprising that the text layer is gone in that version of the file. 

::: {.callout collapse=true}
#### Preview: OCR

Most free OCR tools are based on the `tesseract` library, which you can access using `pytesseract` in python or the `tesseract` R package. 
You can also run `tesseract` from the command line, if you [install the library](https://tesseract-ocr.github.io/tessdoc/Installation.html) for your operating system and language. 

::: panel-tabset

##### Bash {-}

For the sake of shorter commands, let's assume I'm working with a 1-page PDF file named `file.pdf` and want to create `file.txt` which contains the text of the image-based PDF.

```{bash, eval = F}
# Convert PDF to PNG to work with Tesseract
# If file has more than one page, 
# this will create file-1.png ... file-n.png images
pdftoppm -png file.pdf file

# Extract the text
tesseract  -l eng file-1.png file-1.txt
```

Here are the [PNG](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-image-1.png) and [text file](../data/Lancaster-County-NE-Real-Estate-AppraisalCard-28749-2025-147568-pg1-text-1.txt) created by using tesseract on one of the Lancaster county appraisal data sheets. 
Note that with this text document, you can search the PDF for text, but it doesn't provide all of the features that a hybrid PDF with both an image and a text layer provides -- the text isn't associated with the $(x,y)$ location on the page(s). 

##### R {-}

On Mac and Linux, you will likely need to install some system packages to make the `tesseract` package installable. 
```
Try installing:
 * deb: libtesseract-dev libleptonica-dev (Debian, Ubuntu, etc)
 * rpm: tesseract-devel leptonica-devel (Fedora, CentOS, RHEL)
 * brew: tesseract (Mac OSX)
```

```{r}
# install.packages("tesseract")
library(tesseract)
library(pdftools)

pdf_convert("../data/file.pdf", dpi = 600)
eng <- tesseract("eng")

text <- ocr("../data/file-1.png", engine = eng)
text <- str_split(text, "\n", simplify = T)
text[1,1:5]
```


##### Python {-}

If you already have the image created, it's simple to get the text out with `pytesseract`.

```{python}
from PIL import Image
import pytesseract

pytesseract.image_to_string(Image.open('../data/file-1.png')).split("\n")[0:5]
```

If you don't have the image created, you have to first create an image (`imgBlob`) for each page, and then run `image_to_string` on that image. 
Note that this method does not require that you write the image out to a separate file: the image is only stored in memory.
This might be preferable over the bash method, which produces one file for each PDF page. 

```{python}
from pdf2image import convert_from_path

pages = convert_from_path("../data/file.pdf")
for pageNum,imgBlob in enumerate(pages):
  text = pytesseract.image_to_string(imgBlob, lang='eng')
  with open(f'../data/file-py-{pageNum}.txt', 'a') as the_file:
    the_file.write(text)
```

Here is the [text file](../data/file-py-0.txt) created by Python using `pytesseract`. 

:::

:::


::: {.callout collapse=true}
#### Preview: Creating Hybrid PDFs

When I need OCR and don't necessarily want to bother with R, I prefer to use a program called [`ocrmypdf`](https://github.com/ocrmypdf/OCRmyPDF) that is based on tesseract and available for most distributions.
I started using `ocrmypdf` before I realized that it's actually a python package that can just be called from the Linux command line. 

```{bash, eval=F}
ocrmypdf -l eng ../data/file.pdf ../data/file-ocrmypdf.pdf
```


The output of `ocrmypdf` is a [hybrid PDF](../data/file-ocrmypdf.pdf) that has the text and image data superimposed (the text is invisible until you highlight it). 


:::

::::


## Working with PDFs Programmatically

### Reading Data from Text or Hybrid PDFs

The Bureau of Labor Statistics provides monthly Consumer Price Index news releases. 
An archive of these releases is available at https://www.bls.gov/bls/news-release/cpi.htm. 
To demonstrate working with PDFs programmatically, we need to acquire a set of PDFs, and these seem like they will do.

::: {.callout collapse=true}
#### Acquiring 2 years of BLS CPI news releases

```{r acquire-bls-pdfs, eval = F}
library(rvest)
library(lubridate)
library(stringr)

save_dir <- "../data/bls-pdfs/"
dir.create(save_dir, showWarnings = F)

url <- "https://www.bls.gov/bls/news-release/cpi.htm"

session <- read_html_live(url)

# PDFs are the 2nd link in each entry
links <- session$html_elements("li a:nth-child(2)")  

# Get the last 2 years of entries
link_tbl <- tibble(link = html_attr(links, "href"), 
                   date = str_extract(link, "\\d{8}")) |>
  na.omit() |>
  mutate(datestr = date, date = mdy(date)) |>
  filter(today() - years(2) <= date)


ua <- "Mozilla/5.0 (Windows NT x.y; Win64; x64; rv:10.0) Gecko/20100101 Firefox/10.0"
options(HTTPUserAgent = ua)

filelist <- paste0("https://www.bls.gov", link_tbl$link)
filesave <- paste0(save_dir, basename(link_tbl$link))

# The site is finicky about user agents, so we need to 
# specifically pass that in to the download.file method.
walk2(filelist, filesave, ~download.file(.x, destfile = .y, method = "wget", extra = paste0("-U \"", ua, "\"")))
```

:::

You can either run the code above (assuming you have `wget` on your machine), or you can [download a zip file of the PDFs](../data/bls-pdfs/bls-cpi-pdfs.zip). 


:::: example

#### Example: BLS 



## References {-}
