# Computer Basics {#sec-computer-basics}

Before you learn how to program a computer, it can be helpful to learn a few basic things about how computers work.
Modern computing environments hide most of the details about where and how files are stored from the user, but when you write computer programs, these details suddenly become important.

## Objectives {.unnumbered}

-   Know the meaning of computer hardware and operating system terms such as hard drive, memory, CPU, OS/operating system, file system, directory, and system paths

-   Understand the basics of how the above concepts relate to each other and contribute to how a computer works

-   Understand the file system mental model for computers enough to identify where your files are stored

-   Locate and follow directions for software installation based on your computer's hardware and operating system.

::: diy
In this section, you will be identifying your computer's specifications.

You will want to have a notebook or text file that you can reference later to record this information.
Go ahead and determine where you will save this information now.
:::

## Hardware

The components that make up the physical computer are the **hardware**.
This 3-minute video is focused on desktops, but the same components (with the exception of the optical drive) are commonly found in cell phones, smart watches, and laptops.

::: youtube-video-container
{{< video https://www.youtube.com/embed/Rdm8E59L8Og >}}
:::

The important distinction for hardware is between Random Access Memoroy (RAM, or 'memory') and disk storage (hard drives).
You can usually store much more on disk than you can have available in RAM, but when working with "big" data[^01-computer-basics-1], we must use different approaches than when working with data that can fit in memory.

[^01-computer-basics-1]: How big "big" is changes every couple of years -- it used to be several GB circa 2010, and now it's TB of data.

We also need to know at least a little bit about processors (so that we know when we've asked our processor to do too much).
For now, you are unlikely to challenge a modern processor when you first start learning R and Python, but as you acquire new skills, you may want to learn a bit about parallel processing (sending tasks to multiple processors).
Most of the other details aren't critical to programming with data just yet -- graphics cards are important for some applications, but if you're just learning R and python, you have a ways to go before you get there.

::: diy
Examine the hardware on your computer using one of the following methods:

-   Windows: Ctrl+Shift+Escape \> Task Manager \> More Options \> Performance tab
-   Mac: Apple menu \> System Settings \> General (sidebar) \> About \> System Report
-   Linux: The `inxi` command will give you most of this on the command line, and `hwinfo --short` will give you a considerably more detailed printout.

Find out:

-   What processor do you have?\
    This most likely will start with ARM, Intel, AMD, or Apple M1

-   How much RAM do you have?
    (most likely between 8 and 64 GB)

-   How much hard drive space do you have?

-   What graphics device do you have?
    (this might be slightly harder to find -- it's also less critical)
:::

::: learn-more
-   [Chapter 1 of Python for Everybody](https://www.py4e.com/html3/01-intro) - Computer hardware architecture
:::

## Operating Systems

Operating systems, such as Windows, MacOS, or Linux, are a sophisticated program that allows CPUs to keep track of multiple programs and tasks and execute them at the same time.

::: youtube-video-container
{{< video https://www.youtube.com/embed/RhHMgkUdhdk >}}
:::

Chances are, you can't imagine doing computing without an operating system of some sort (and they've been ubiquitous on computers since the late 1980s).
Even some appliances now have enough computing functions to require an operating system and an internet connection!
Technically, you can use some [Arduino and Raspberry Pi](https://electronics.stackexchange.com/questions/35247/raspberry-pi-without-os-on-it#35258) boards without an operating system[^01-computer-basics-2], but anything more complicated is almost guaranteed to have some minimal operating system available.

[^01-computer-basics-2]: Chips and boards used without an operating system are often called "embedded systems".

You should be able to identify your operating system (OS for short) and follow instructions based on that information.
You will typically need to know not only the class of operating system (Windows/Mac/Linux) but also the version (e.g. Windows 11, Mac OSX Sierra, Debian 12, RedHat 7).

::: diy
Locate your operating system and version information.
When was your system last updated?

If your system hasn't been updated in a while, consider updating it now -- system updates may break software you'll install to work with R and python packages in @sec-setting-up[^01-computer-basics-3].
:::

[^01-computer-basics-3]: If you are using an operating system that is older, know that some of the installation instructions may require modification (but there are likely others online who have attempted something similar, so you can usually Google for how to adjust things when they don't work).

## File Systems

File systems are, unsurprisingly, places you save files.
They are modeled after physical file cabinets -- individual documents are kept in a hierarchical sequence of folders.
Ultimately, a collection of folders is stored on a **drive**.

Evidently, there has been a bit of generational shift as computers have evolved: the "file system" metaphor itself is outdated because no one uses physical files anymore, and new apps don't show the user where on the computer their files are stored, forcing users to rely on the search feature instead of understanding file folders and paths.
[Dan Robitzski provided an interesting discussion of the problem](https://futurism.com/the-byte/gen-z-kids-file-systems), making the argument that with modern search capabilities, most people use their computers as a laundry hamper instead of as a nice, organized closet and dresser (or file cabinet) [@robitzskiGenKidsApparently2021].

::: youtube-video-container
{{< video https://www.youtube.com/embed/KN8YgJnShPM >}}
:::

Regardless of how you tend to organize your personal files, it is probably helpful to understand the basics of what is meant by a computer **file system** -- a way to organize data stored on a hard drive.
Since data is always stored as 0's and 1's, it's important to have some way to figure out what type of data is stored in a specific location, and how to interpret it.

::: youtube-video-container
{{< video https://www.youtube.com/embed/BV0-EPUYuQc >}}
:::

### Local and Network File Systems

It is important to distinguish between two primary types of file systems.

-   **local file storage**: files are stored on a physical disk contained within the machine you are actively using.
    A local file might be found at an address like `C:/Users/username/\ Documents/unnamed.txt` or `/home/users/username/Documents/unnamed.txt` or `/Users/username/Documents/unnamed.txt`.

-   **network file storage**, where files are stored "in the cloud" and you may have a link or a copy on your local machine.\
    Examples of network storage are Google Drive, Dropbox, Microsoft OneDrive, and iCloud.
    Organizations may have privately-hosted network file storage, but these services are still dependent on access to the internet and thus fall under network file storage.

If you have used primarily mobile devices or Chromebook-style laptops, then you have likely dealt primarily with network storage.
When programming, it is **essential** to know where your files are being stored.
You cannot conduct a file search to find your data and code (this is an interactive process).
Instead, you will need to keep all of the files you need for a project together in a folder, and then keep track of where the project folder is stored.

Some operating systems (Windows, Mac OS) prefer to save files in network storage services that may (or may not) be also stored on your physical hard drive.
Over time, it has become harder to ensure that you are working on a local machine, but working "in the cloud" can cause odd errors when programming and in particular when working with version control systems[^01-computer-basics-5]

::: callout-caution
You want to save your files in this class to your **physical hard drive**.
This will save you a lot of troubleshooting time.
:::

[^01-computer-basics-5]: To disable OneDrive sync for certain windows folders, use [this guide](https://support.microsoft.com/en-us/office/files-save-to-onedrive-by-default-in-windows-10-33da0077-770c-4bda-b61e-8c8e8ca70ac7). On Mac, see ["Turn off Desktop and Documents"](https://support.apple.com/en-us/109344) to stop iCloud sync of your Desktop and Documents folders (you can still manually copy things into iCloud for backup). 


### Allowed File Names

Different operating systems have different rules for how file names are handled within the file system.

|   | Windows <i class="fa-brands fa-windows"></i> | Mac OSX <i class="fa-brands fa-apple"></i> | Linux <i class="fa-brands fa-linux"></i> |
|--------------|-------------------|--------------|--------------------------|
| Disallowed Characters | `<`, `>`, `"`, `/`, `\`, `|`, `?`, `*` | `:`, some programs will restrict use of `/` . Avoid names that start with `.` unless the file should be hidden. | NULL character, `/` . Can't name files `.` or `..` . Avoid `\`, `"`, `'`, `*`, `;`, `?`, `[`, `]`, `(`, `)`, `~`, `!`, `$`, `<`, `>`, `#`, `@`, `&`, `|`, spaces, tabs, and newlines. Avoid names that start with `.` unless the file should be hidden. |
| Case Sensitive | No. `A.jpg` is the same as `a.JPG` | [It's complicated](https://discussions.apple.com/thread/251191099?sortBy=rank). Act as if it's case sensitive to be safe. | Yes. `A.jpg` is different from `a.jpg` and `A.JPG` |
| Name Length | Entire file path should be \<256 characters[^01-computer-basics-4]. | (For HFS+ systems) File names \< 255 characters. File paths can be longer. | File names \< 255 characters, File paths \< 4096 characters (most file system options, including ext4) |

: File Naming Rules. All length limits assume UTF-8 characters -- limits may be shorter when using multibyte characters. 

[^01-computer-basics-4]: Longer paths [can be enabled via registry edits if you're brave/foolish](https://support.cs.jhu.edu/wiki/Windows_Path_Length_Limit_Reached).

:::: example
#### Example {-}

::: panel-tabset
##### Setup {-}

A Windows user saves a picture as `my-pup.png` and references the picture in a file as `![Puppy picture](My-pup.PNG)`. 
The picture link works fine when compiled on the Windows machine, but causes an error when the folder is copied to a Linux server and compiled. 

What do you think the error might look like? 

What went wrong?

How can the user ensure that the picture link works on every operating system?

##### Answer {-}

On the Linux machine the user will get a file not found error. 


Windows is a case-insensitive operating system, so `my-pup.png` and `My-pup.PNG` will both point to the same file. 
Thus, when referencing the picture `My-pup.PNG`, the system finds `my-pup.png` and concludes they are the same file. 

Linux is a case-sensitive operating system, which means that `my-pup.png` and `My-pup.PNG` point to different files. 
On Linux, the file reference is to `My-pup.PNG`, and the only file in the directory is `my-pup.png`, which doesn't match the specified file name. 
Thus, Linux will raise a **file not found** error because the file `My-pup.PNG` does not exist on the system. 


The user should reference `my-pup.png` instead of `My-pup.PNG`. This file name will work across all major operating systems. 

:::
::::



### File Paths

::: youtube-video-container
{{< video https://www.youtube.com/embed/BMT3JUWmqYY >}}
:::

When you write a program, you may have to reference external files - data stored in `data.csv`, a diagram or picture, or a link to additional documentation.

To handle this need, most programmers use a shortcut: they create a project-specific folder, and then include the files that are required for that project within the folder.
@picardiProjectOrganization2024 discusses several common layouts used for research projects, but using RStudio tends to ensure a slightly more structured approach to projects.

```
- Project-Name/
    - data/
        - `descriptive-data-name.csv`
    - analysis.R
    - writeup.qmd
    - project.Rproj
```

The structure above indicates a folder (`Project-Name`) and a subfolder (`data`). 
The `project.Rproj` file contains RStudio settings for the project and also tells RStudio where to look for associated code and data when the project is opened.
At the most basic level, the project folder might contain an analysis script (`analysis.R`) and a write-up of the project (`writeup.qmd`). 

The "base folder" , `Project-Name`, is known as your **working directory** - the place your program thinks of as home.
When working within a project, you can use **local** or **relative paths** to reference files -- for instance, you can read in your data with `read.csv("data/descriptive-data-name.csv")`

XXX stopped here 
## System Paths

When you install software, it is saved in a specific location on your computer, like C:/Program Files/ on {{< fa brands windows >}}, /Applications/ on {{< fa brands apple >}}, or /usr/local/bin/ on {{< fa brands linux >}}.
For the most part, you don't need to keep track of where programs are installed, because the install process (usually) automatically creates icons on your desktop or in your start menu, and you find your programs there.

Unfortunately, that isn't sufficient when you're programming, because you may need to know where a program is in order to reference that program -- for instance, if you need to pop open a browser window as part of your program, you're (most likely) going to have to tell your computer where that browser executable file lives.

To simplify this process, operating systems have what's known as a "system path" or "user path" - a list of folders containing important places to look for executable and other important files.
You may, at some point, have to edit your system path to add a new folder to it, making the executable files within that folder more easily available.

::: callout-warning
#### Error Messages That Indicate Path Problems

If you run across an error like this:

-   could not locate xxx.exe
-   The system cannot find the path specified
-   Command Not Found

You might start thinking about whether your system path is set correctly for what you're trying to do.
:::

:::: demo
#### Demonstration: Path Errors

Let's see what path errors look like using different tools you might encounter.

::: panel-tabset
##### R

```{r}
#| error: true
tmp <- read.csv("lego_sets.csv") # Wrong Path

tmp <- read.csv("../data/lego_sets.csv") # Right Path
```

##### Python

```{python}
#| error: true
import pandas as pd

tmp = pd.read_csv("lego_sets.csv") # Wrong Path

tmp = pd.read_csv("../data/lego_sets.csv") # Right Path
```

##### Bash

```{bash}
head -n5 lego_sets.csv
```
:::
::::

If you want to locate where an executable is found (in this example, we'll use `git`), you can run `where git` on windows, or `which git` on OSX/Linux.

Some programs, like RStudio, have places where you can set the locations of common dependencies.
If you go to Tools \> Global Options \> Git/SVN, you can set the path to git.

### How To Modify System Paths {.unnumbered}

[How to set system paths (general)](https://superuser.com/a/284361/391106)

Operating-system specific instructions cobbled together from a variety of different sources:

-   {{< fa brands windows >}} [On Windows](https://miktex.org/howto/modify-path)
-   {{< fa brands apple >}} [On Mac](https://osxdaily.com/2014/08/14/add-new-path-to-path-command-line/)
-   {{< fa brands linux >}} [On Linux](https://linuxize.com/post/how-to-add-directory-to-path-in-linux/)

<!-- ## Working Directories -->

<!-- When you launch a program, that program starts up with a specific directory as its "location" - the place where it will look for files. Most of the time, we don't think too much about this when using graphical programs, but it's much more important to get this right when programming things ourselves. -->

<!-- In RStudio, you can set your working directory in several ways: -->

<!-- 1. Work in an RStudio Project (File > New Project), which will make it easy to access your project folder, and will set your working directory to the right folder automatically. I've created a project in `/home/susan/Projects/Class/unl-stat850/test-project`     -->

<!-- ![Setup window for RStudio projects](../images/tools/test-project-setup.png) -->

<!-- 2. Use `setwd()` to set your working directory. If I'm not working in the RStudio project described above, I can set my working directory to that folder using: -->

<!-- `setwd("/home/susan/Projects/Class/unl-stat850/test-project")` -->

<!-- 3. Use the files tab (bottom right) to navigate to your preferred folder. Then, click More > Set As Working Directory. -->

<!-- In this class, we're going to focus on **reproducibility** - making sure your code runs on any other computer with the right project setup. So with that in mind: -->

<!-- 1. Work in (RStudio) projects^[None of the good practices here are dependent on RStudio, but RStudio projects do make it easier for you to e.g. keep track of where files are living and what your current working directory is. You can do the same thing in a purely python project if you want to, but think of RStudio here as training wheels for those in the class who are not familiar with file paths and reproducibility.] -->

<!-- 2. Store the data for the project in your project folder -->

<!-- 3. Use local paths - if you're in your project folder and trying to reference "data.xls", then you would just use "data.xls" as the path. If your data is in a "code" folder, you would use "code/data.xls" as the path. -->

<!-- This will ensure that your code should work on any other machine, as long as your data is in your project folder and your code uses local file paths. -->

## References {#part-tools-01-refs}
